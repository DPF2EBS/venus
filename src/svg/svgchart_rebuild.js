/*
 * SVG Chart Lib of Venus
 * */

;
(function (global, undefined) {
    /*
     * cache global.Venus to Venus
     * */
    var Venus = global.Venus;

    /* make some global variables local */
    var util = Venus.util
        , mix = util.mix
        , PI = Math.PI
        , isArray = util.isArray
        , isObject = util.isObject
        , getColor = util.getColors

    // charts added  using Venus.SvgChart.addChart
        , charts = {}

        , DEFAULT_Y_AXIS = "y"
        , DEFAULT_X_AXIS = "x"
        , UNDER_TICK = 'under-tick'
        , CONTINUOUS  = "continuous"
        , DISCRETE =  'discrete'
        , DATETIME = "datetime";

    /*Chart Begin*/
    /*
     * Class Chart
     * @param container{HTMLElement} container of the svg element to draw the chart
     * @param data{Array,Object} data can be array or object
     * @param options{object}
     *
     *  will bind to Venus.SvgChart later
     */
    function Chart(container, data, options) {
        container = typeof container === "string" ? document.getElementById(container) : container;
        if (!container || !container.nodeType) {
            //not dom
            return;
        }
        this.container = container;
        this.data = data || [];
        this.events = new Venus.util.CustomEvent();

        //default options
        var defaultOptions = {
            /*
             * width and height  equals the containers width and height by default
             * but when the container is invisible ,please parse the width and height manually
             * */
            width:container.clientWidth,
            height:container.clientHeight,

            /*
             * colors will be auto generated by calling Venus.util.getColors if you don't parse an array
             * */
            colors:[],

            /*
             * axises usually are x and y .
             * actually you can create any numbers of axises
             * For detail see Class Axis
             * */
            axis:{
            },

            /*
            * config each series  which two axises are used as the x and y axis
            *  for example :
            *  axisUsage:{
            *      0:['x','y']
            *      1:['x','y1']
            *  }
            *  x and y axis are used by default
            *
            * */
            axisUsage:{},

            /*
             * grid under the chart has the follow config options:
             * enableRow
             * enableColumn
             * opacity
             *
             * no grid by default
             *
             * for detail , see Class Grid
             * */
            grid:{
                opacity:0.4
            },

            /*
            * config tooltip text
            * tooltip will call this function to get the tooltip text and will parsed in an object
            * obj contains
            * {
            *     x: x axis value
            *     y: y axis value
            *     label: name of this series
            * }
            * */
            tooltip:function (obj) {
               // return obj.label + " " + obj.x + " " + obj.y;
                return obj.y;
            },

            /*
            * config series icons
            * {
            *     0:"rect",
            *     1:"circle",
            *     2:"triangle",
            *     3:"lozenge"
            * }
            *
            * */
            icons:{
            },

            /*
            * threshold lines
            * {
            *     y:{
            *         value:10
            *     }
            * }
            * */
            threshold:{

            }
        }, self = this;

        //clone and mix options
        this.options = mix(defaultOptions,util.clone(options)|| {});

        //init raphael
        this.stage = new Raphael(container, this.options.width, this.options.height);

        //to fix FireFox bound box bug
        this.stardBox = this.stage.rect(0,0,this.options.width,this.options.height).attr('stroke-width',0)

        //new! coordinate object
        this.coordinate = this._initCoordinate();

        //new! icon factory
        this.iconFactory = this._initIconFactory();

        //init events
        this._initEvents();

        //init data
        this._initData();
        this.events.fire('onDataInit', this.series);

        this.colors = this.options.colors && this.options.colors.length ? this.options.colors : getColor(this.series.getSeries().length);

        // init axis
        this._initAxis();
        this.events.fire('onAxisInit', {});

        //init labels
        this._initLabels();

        //init legend
        this._initLegend();
        this.events.fire('onLegendInit', this.legend);

        // draw
        this._draw();

        //init grid
        this._initGrid();
        this.events.fire('onGridInit', this.grid);

        // init threshold line
        this._initThreshold();

        // render axis ui
        this._renderAxis();

        this.events.fire('onFinish');

    }
    Chart.prototype = {
        constructor:Chart,
        _initData:function () {
            this.series = new Series(this.data);
        },
        _initLabels:function(){
            var data = this.series.getSeries(),
                labels = this.series.getLabels(),
                _labels = [],
                self = this,
                coordinate = self.coordinate;

            data.forEach(function (d, j) {
                if (d.name !== undefined) {
                    //if got name , use name
                    _labels.push(d.name);
                } else if (Venus.util.isNumber(d.data)) {
                    //if data is number , use label or x ticks because labels may be empty
                    _labels.push(labels[j] || (coordinate.x && coordinate.x.options.ticks ? coordinate.x.options.ticks[j] || '' : ""));
                } else {
                    //otherwise there's no way to get the names , let it be empty
                    _labels.push('');
                }
            });
            this.labels = _labels;
        },
        _initCoordinate:function () {
            var self = this,
                options = self.options;
            return {

                /*
                 * axises are stored in this object
                 * axises:{
                 *     x:,
                 *     y:,
                 *     x1:,
                 *     y1:,...
                 * }
                 * */
                axises:{},

                /*
                 * add axis
                 * */
                push:function (name, axis) {
                    this.axises[name] = axis
                },

                /*
                 * use two axis to generate the coordinate
                 * */
                use:function (x, y) {
                    if(isObject(x)){
                        this.x = this.axises[x.x];
                        this.y = this.axises[x.y];
                        this.xName = x.x;
                        this.yName = x.y;
                        return;
                    }
                    this.x = this.axises[x];
                    this.y = this.axises[y];
                    this.xName = x;
                    this.yName = y;
                },

                /*
                 * use the coordinate generated by 'use' function
                 * returns x and y position in svg
                 * */
                get:function (key, value) {
                    var xOpt = this.x.options,
                        yOpt = this.y.options,
                        xModel = this.x.model,
                        yModel = this.y.model,
                        xObj , yObj,
                        x, y, xTick, yTick;

                    xObj = this.x.getPoint(key);
                    x = xObj.length;
                    xTick = xObj.tick;

                    yObj = this.y.getPoint(value);
                    y = yObj.length;
                    yTick = yObj.tick;

                    if(yModel.reverse){
                        y = yModel.totalWidth - y;
                    }
                    if(xModel.reverse){
                        x = xModel.totalWidth - x;
                    }
                    if (xModel.rotate == 90 && yModel.rotate == 0) {
                        //x axis is vertical and y axis is horizontal
                        return {
                            y:xModel.beginY - x,
                            x:yModel.beginX + y,
                            xTick:xTick,
                            yTick:yTick
                        }
                    } else {
                        return {
                            x:xModel.beginX + x,
                            y:yModel.beginY - y,
                            xTick:xTick,
                            yTick:yTick
                        }
                    }
                },

                /*
                * get the size of the coordinate
                * */

                size:function () {
                    var width, height;
                    if (this.x.model.rotate == 90) {
                        height = this.x.model.totalWidth;
                    } else {
                        width = this.x.model.totalWidth;
                    }
                    if (this.y.model.rotate == 90) {
                        height = this.y.model.totalWidth;
                    } else {
                        width = this.y.model.totalWidth;
                    }
                    return {
                        width:width,
                        height:height
                    }
                },

                /*
                * get the distance from an point to an axis
                * point - axis
                * it could be negative
                * */

                distance:function (axis, point) {
                    if (axis.model.rotate == 0) {
                        return point.y - axis.model.beginY;
                    } else {
                        return point.x - axis.model.beginX;
                    }
                },


                /*
                 * get which two axises to use
                 *
                 * */
                getAxisUse:function (i) {
                    if (!this.axisUsageArray) {
                        var arr = this.axisUsageArray = [];
                        self.series.getSeries().forEach(function (s, _index) {
                            if (!options.axisUsage || !options.axisUsage[_index]) {
                                arr.push({
                                    x:DEFAULT_X_AXIS,
                                    y:DEFAULT_Y_AXIS
                                });
                            }else{
                                arr.push({
                                    x: options.axisUsage[_index][0] || DEFAULT_X_AXIS,
                                    y:options.axisUsage[_index][1] || DEFAULT_Y_AXIS
                                });
                            }
                        });
                    }
                    return this.axisUsageArray[i];
                },
                /*
                * get related series array
                *
                * */
                getRelatedSeries:function(axisName){
                    var result = [],
                        axisUsage = self.options.axisUsage;
                    if (axisName == DEFAULT_X_AXIS) {
                        self.series.getSeries().forEach(function (s, i) {
                            if (!axisUsage || !axisUsage[i] || !axisUsage[i][0]) {
                                result.push(i);
                            }
                        });
                    } else if (axisName == DEFAULT_Y_AXIS) {
                        self.series.getSeries().forEach(function (s, i) {
                            if (!axisUsage || !axisUsage[i] || !axisUsage[i][1]) {
                                result.push(i);
                            }
                        });
                    }else {
                        self.series.getSeries().forEach(function (s, i) {
                            if (axisUsage && axisUsage[i] && (axisUsage[i][0] === axisName || axisUsage[i][1]===axisName)) {
                                result.push(i);
                            }
                        });
                    }
                    return result;
                },
                useDefault:function(){
                    this.use(DEFAULT_X_AXIS,DEFAULT_Y_AXIS);
                },
                type:function(axis){
                    typeof axis==="string" || (axis = axis.axisName);
                    return axis.indexOf('x') == 0 ? 'x' : 'y';
                },
                isX:function(axis){
                    return this.type(axis)=='x';
                },
                isY:function(axis){
                    return this.type(axis)=='y';
                }
            };
        },
        _initIconFactory:function () {
            var self = this,
            /*
                * build-in icons for legend , line and others
                * currently contains 'rect','circle','triangle'
                * each icon must extends interfaces below:
                * create{Function} ,receives stage, x, y , width and returns an object contains raphael element, size ,position,animate function
                *          stage is the raphael instance;
                *          x,y is the center of the element;
                *          width is the width of the element;
                * size{Function} , receives the 'width' param and set the width of the element
                * position{Function}, set or get the position of the element, that is the coordinate of the center of the element
                * animate{Function}, delegate raphael element and custom the x,y,width animation
                *
                * */
                nativeIcons = {
                    'rect':{
                        create:function (stage, x, y, width) {
                            return {
                                icon:stage.rect(x - width / 2, y - width / 2, width, width),
                                position:this.position,
                                animate:this.animate,
                                size:this.size
                            }
                        },
                        size:function (w) {
                            this.icon.attr('width', w);
                        },
                        position:function (x, y) {
                            if (arguments.length == 0) {
                                return{
                                    x:this.icon.attr('x') + this.icon.attr('width') / 2,
                                    y:this.icon.attr('y') + this.icon.attr('width') / 2
                                }
                            }
                            this.icon.attr({
                                'x':x,
                                'y':y
                            });
                        },
                        animate:function (obj, duration) {
                            if (obj.x) {
                                obj.x = obj.x - this.icon.attr('width') / 2;
                            }
                            if (obj.y) {
                                obj.y = obj.y - this.icon.attr('width') / 2;
                            }
                            if (obj.width) {
                                obj.height = obj.width;
                                if (!obj.x && !obj.y) {
                                    var icon = this.icon,
                                        delta = obj.width - icon.attr('width');
                                    obj.x = icon.attr('x') - delta / 2;
                                    obj.y = icon.attr('y') - delta / 2;
                                }
                            }
                            this.icon.animate(obj, duration);
                        }
                    },
                    'circle':{
                        create:function (stage, x, y, width) {
                            return {
                                icon:stage.circle(x, y, width / 2),
                                position:this.position,
                                animate:this.animate,
                                size:this.size
                            }
                        },
                        size:function (w) {
                            this.icon.attr('r', w / 2);
                        },
                        position:function (x, y) {
                            if (arguments.length == 0) {
                                return{
                                    x:this.icon.attr('cx'),
                                    y:this.icon.attr('cy')
                                }
                            }
                            this.icon.attr({
                                'cx':x,
                                'cy':y
                            });
                        },
                        animate:function (obj, duration) {
                            for (var o in obj) {
                                if (o == 'x') {
                                    obj.cx = obj[o];
                                } else if (o == 'y') {
                                    obj.cy = obj[o];
                                } else if (o == 'width') {
                                    obj.r = obj[o] / 2;
                                }
                            }
                            delete obj.x;
                            delete obj.y;
                            delete obj.width;
                            this.icon.animate(obj, duration);
                        }
                    },
                    'triangle':{
                        create:function (stage, x, y, width) {
                            return {
                                icon:stage.path().attr({
                                    path:['M', x - width / 2, y + width / 2 * Math.tan(PI / 6), 'l', width / 2, -width / 2 * Math.tan(PI / 3), 'l', width / 2, width / 2 * Math.tan(PI / 3)],
                                    'stroke-width':0
                                }),
                                position:this.position,
                                animate:this.animate,
                                size:this.size,
                                x:x,
                                y:y,
                                width:width
                            }
                        },
                        size:function(width){
                            var icon = this.icon,
                                x = this.x,
                                y = this.y;

                            icon.attr('path',['M', x - width / 2, y + width / 2 * Math.tan(PI / 6), 'l', width / 2, -width / 2 * Math.tan(PI / 3), 'l', width / 2, width / 2 * Math.tan(PI / 3)]);
                            this.width = width;
                        },
                        position:function(x,y){
                            var icon = this.icon,
                                width = this.width;

                            if (arguments.length == 0) {
                                return{
                                    x:this.x,
                                    y:this.y
                                }
                            }
                            icon.attr('path',['M', x - width / 2, y + width / 2 * Math.tan(PI / 6), 'l', width / 2, -width / 2 * Math.tan(PI / 3), 'l', width / 2, width / 2 * Math.tan(PI / 3)]);
                        },
                        animate:function(obj, duration){
                            var icon = this.icon,
                                width = this.width,
                                x = this.x,
                                y = this.y

                            if ('x' in obj || 'y' in obj || 'width' in obj) {
                                width = (obj.width || width);
                                var path = ['M',(obj.x || x) - width / 2, (obj.y || y) + width / 2 * Math.tan(PI / 6), 'l', width / 2, -width / 2 * Math.tan(PI / 3), 'l', width / 2, width / 2 * Math.tan(PI / 3)]
                                this.x = (obj.x || x);
                                this.y = (obj.y || y);
                                this.width = width;
                                obj.path = path;
                            }

                            delete obj.x;
                            delete obj.y;
                            delete obj.width;
                            icon.animate(obj, duration);
                        }
                    },
                    'lozenge':{
                        create:function (stage, x, y, width) {
                            return {
                                icon:stage.path().attr({
                                    path:['M', x - width / 2, y , 'l', width / 2, -width / 2 , 'l', width / 2, width / 2 ,'l',-width/2,width/2,'l',-width/2,-width/2],
                                    'stroke-width':0
                                }),
                                position:this.position,
                                animate:this.animate,
                                size:this.size,
                                x:x,
                                y:y,
                                width:width
                            }
                        },
                        size:function(width){
                            var icon = this.icon,
                                x = this.x,
                                y = this.y;

                            icon.attr('path',['M', x - width / 2, y , 'l', width / 2, -width / 2 , 'l', width / 2, width / 2 ,'l',-width/2,width/2,'l',-width/2,-width/2]);
                            this.width = width;
                        },
                        position:function(x,y){
                            var icon = this.icon,
                                width = this.width;

                            if (arguments.length == 0) {
                                return{
                                    x:this.x,
                                    y:this.y
                                }
                            }
                            icon.attr('path',['M', x - width / 2, y , 'l', width / 2, -width / 2 , 'l', width / 2, width / 2 ,'l',-width/2,width/2,'l',-width/2,-width/2]);
                        },
                        animate:function(obj, duration){
                            var icon = this.icon,
                                width = this.width,
                                x = this.x,
                                y = this.y

                            if ('x' in obj || 'y' in obj || 'width' in obj) {
                                width = (obj.width || width);
                                var path = ['M', (obj.x||x) - width / 2, (obj.y || y) , 'l', width / 2, -width / 2 , 'l', width / 2, width / 2 ,'l',-width/2,width/2,'l',-width/2,-width/2]
                                this.x = (obj.x || x);
                                this.y = (obj.y || y);
                                this.width = width;
                                obj.path = path;
                            }

                            delete obj.x;
                            delete obj.y;
                            delete obj.width;
                            icon.animate(obj, duration);
                        }
                    }
                },

                /*
                * default icon is rect
                * */
                defaultIcon = 'rect';
            return {
                defaultIcon:defaultIcon,
                icons:self.options.icons,
                create:function (i, x, y, width) {
                    /*
                    * factory function to create an icon element
                    * i{Number}:index
                    * x,y {Number}:position of the center of the element
                    * width{Number}:width of the element
                     * this function will call the build-in icon create function or function parsed in the icons options
                    *
                    * */
                    var iconType = this.icons[i] || defaultIcon;
                    if (typeof iconType === "string") {
                        //if string , call the build-in icons
                        return nativeIcons[iconType].create(self.stage, x, y, width);
                    } else if (util.isObject(iconType)) {
                        //call the icons parsed in the icons options
                        //it must implement the icon interface as build-in icons
                        return  iconType.create(self.stage, x, y, width);
                    }
                },
                nativeIcons:nativeIcons
            }

        },
        _initAxis:function () {
            var opt = this.options,
                axisOption = opt.axis,
                axis,
                thisAxisOption,
                range,
                beginX,
                beginY,
                seriesArray = [],
                thisAxis,
                coordinate = this.coordinate;

            for (axis in axisOption) {
                if (!axisOption.hasOwnProperty(axis)) {
                    continue;
                }
                //init each axis in options.axis
                if ((thisAxisOption = axisOption[axis])) {
                    //set rotate 90 for y axis by default
                    (coordinate.isY(axis) && !('rotate' in thisAxisOption)) && (thisAxisOption.rotate = 90);

                    if (coordinate.isY(axis) && !axisOption.ticks) {
                        //if y axis has no ticks , then auto generate ticks use series.getRange()
                        seriesArray = coordinate.getRelatedSeries(axis);
                        //get range
                        range = this.series.getRange(seriesArray);

                        //set max and min
                        thisAxisOption.max === undefined && (thisAxisOption.max = range.max);
                        thisAxisOption.min === undefined && (thisAxisOption.min = range.min);
                    }
                    if (coordinate.isX(axis)) {
                        //set pop=1 for x Axis by default
                     //   (thisAxisOption.pop === undefined) && (thisAxisOption.pop = 1);

                        (thisAxisOption.percent === undefined) && (thisAxisOption.percent =.9);

                        //if x axis has no ticks , then auto generate ticks use series.getLabels()
                        //but getLabels() sometimes returns array of empty string depends on the data
                        if (!thisAxisOption.ticks) {
                            thisAxisOption.ticks = this.series.getLabels();
                        }
                        if (thisAxisOption.type == DATETIME && this.series.getLength()>1) {
                            //datetime axis , get min and max
                            var ticks = [];
                            thisAxisOption.ticks.forEach(function (t) {
                                ticks.push(util.date.parse(t, thisAxisOption.fromFormat));
                            });
                            ticks.sort(function (a, b) {
                                return +a - +b;
                            });
                            thisAxisOption.min = ticks[0];
                            thisAxisOption.max = ticks[ticks.length - 1];
                        } else {
                            thisAxisOption.type = DISCRETE;
                        }
                    }

                    if (coordinate.isY(axis) && axis !== DEFAULT_Y_AXIS) {
                        thisAxisOption.opposite = true;
                    }

                    thisAxisOption._svgWidth = this.options.width;
                    thisAxisOption._svgHeight = this.options.height;
                    thisAxisOption._name = axis;

                    thisAxis = new Axis(thisAxisOption, this.series, this.stage);
                    coordinate.push(axis, thisAxis);

                    if (thisAxis.model.rotate == 0) {
                        beginX = Math.min(beginX || opt.width, (opt.width - thisAxis.model.totalWidth) / 2);
                    } else if (thisAxis.model.rotate == 90) {
                        beginY = Math.min(beginY || opt.width, (opt.height - thisAxis.model.totalWidth) / 2);
                    }
                }
            }

            this.coordinate.use(DEFAULT_X_AXIS, DEFAULT_Y_AXIS);


            for (axis in coordinate.axises) {
                if (!coordinate.axises.hasOwnProperty(axis)) {
                    continue;
                }
                //thisAxis is the Axis instance
                thisAxis = coordinate.axises[axis];

                if (thisAxis.options.opposite) {
                    //if it is opposite, reset it's beginX ,beginY
                    if (thisAxis.model.rotate == 90) {
                        thisAxis.model.beginX = beginX + coordinate.size().width;
                        thisAxis.model.beginY = opt.height - beginY;
                    } else {
                        thisAxis.model.beginX = beginX;
                        thisAxis.model.beginY = opt.height - beginY - coordinate.size().height;
                    }
                    if (coordinate.isX(axis)) {
                        //if x axis is opposite , reverse all the y axises
                        for (var o in coordinate.axises) {
                            if (coordinate.isY(o)) {
                                coordinate.axises[o].model.reverse = true;
                            }
                        }
                    }
                } else {
                    thisAxis.model.beginX = beginX;
                    thisAxis.model.beginY = opt.height - beginY;
                }
            }


            //set this property false
            //and before it is true , set model will not immediately rerender the ui
            //it will be changed to true in _renderAxis method
            this.axisRendered = false;
        },
        _renderAxis:function () {
            var o , axises = this.coordinate.axises;
            for (o in axises) {
                if (axises.hasOwnProperty(o)) {
                    axises[o].axisRendered = true;
                    axises[o].autoModel();
                    axises[o].render();
                }
            }
            this.axisRendered = true;
        },
        _initLegend:function () {
            /*
             * init legend
             * */

            var opt = this.options,
                legendOption = opt.legend,
                coordinate = this.coordinate,
                series = this.series,
                legend,
                axisName,
                axis,
                relatedSeries,
                activeRelatedSeries,
                range;

            if (legendOption && this.series.getSeries().length) {
                //set options for legend
                legendOption._svgWidth = opt.width;
                legendOption._svgHeight = opt.height;
                legendOption.colors = this.colors;
                legendOption.names = this.labels;

                //if there are ticks of x axis , parse to legend for some use
               // this.coordinate.axises.x && this.coordinate.axises.x.options.ticks && ( legendOption._ticks = this.coordinate.axises.x.options.ticks);

                legend = this.legend = new Legend(this, legendOption, this.stage);
                legend.onActiveChange(function (active,activeArray) {
                    for (axisName in coordinate.axises) {
                        axis = coordinate.axises[axisName];
                        relatedSeries = coordinate.getRelatedSeries(axisName);
                        activeRelatedSeries = [];
                        relatedSeries.forEach(function (i) {
                            if (active[i]) {
                                activeRelatedSeries.push(i);
                            }
                        });
                        if ((!axis.options.ticks || !axis.options.ticks.length ) && activeRelatedSeries.length) {
                            range = series.getRange(activeRelatedSeries);
                            axis.set({
                                min:range.min,
                                max:range.max
                            });
                        }
                    }
                });

            }
        },
        _initGrid:function () {
            var gridOption = this.options.grid,
                coordinate = this.coordinate,
                rows = [],columns = [];
            //generate positions of  rows and columns
            function generatePositions() {
                rows = [];
                columns = [];
                if (gridOption.enableRow) {
                    //use coordinate.y to generate rows
                    if (coordinate.y && coordinate.y.model.rotate == 90) {
                        coordinate.y.forEach(function(i,length){
                            rows.push(coordinate.y.model.beginY-length)
                        });
                        gridOption._x = coordinate.x.model.beginX;
                    } else if (coordinate.x && coordinate.x.model.rotate == 90) {
                        coordinate.x.forEach(function (i, length) {
                            rows.push(coordinate.x.model.beginY - length)
                        });

                        gridOption._x = coordinate.y.model.beginX;
                    }
                    gridOption.width = coordinate.size().width || 0;
                    gridOption.rows = rows;
                }
                if (gridOption.enableColumn) {
                    if (coordinate.y && coordinate.y.model.rotate == 0) {
                        coordinate.y.forEach(function(i,length){
                            columns.push(coordinate.y.model.beginX+length)
                        });
                        gridOption._y = coordinate.x.model.beginY;
                    } else if (coordinate.x && coordinate.x.model.rotate == 0) {
                        coordinate.x.forEach(function (i, length) {
                            columns.push(coordinate.x.model.beginX + length)
                        });
                        gridOption._y = coordinate.y.model.beginY;
                    }
                    gridOption.height = coordinate.size().height || 0;
                    gridOption.columns = columns;
                }

            }
            generatePositions();

            var grid = this.grid = new Grid(gridOption, this.stage);
            coordinate.y && coordinate.y.on(function () {
                generatePositions();
                util.mix(grid.options, gridOption);
                grid.options.rows = gridOption.rows;
                grid.options.columns = gridOption.columns;
                grid.render();
            });

        },
        _initThreshold:function(){
            var options = this.options,
                coordinate = this.coordinate,
                threshold = options.threshold,
                axisName,
                axis,value;

            if (threshold && util.isObject(threshold)) {
                for (var axisName in threshold) {
                    if ((axis = coordinate.axises[axisName]) && util.isObject(threshold[axisName]) && (value = threshold[axisName].value)){
                        new Threshold(axisName,value,coordinate,this.stage);
                    }
                }
            }
        },
        _initEvents:function () {
            var opt = this.options,self = this;
            if(opt.events){
                for(var event in opt.events){
                    this.events.on(event, function(){
                        opt.events[event].apply(self,arguments)
                    });
                }
            }
        },
        _draw:function () {
            var chart ,chartOption;
            for (chart in charts) {
                if (chartOption =  this.options[chart]) {
                    //draw each chart in options , so you can put several type of charts in one svg
                    charts[chart].draw && charts[chart].draw.call(this, chartOption);
                }
            }
        },
        destroy:function(){
            this.stage && this.stage.clear();
            this.stage = null;
            this.container.innerHTML = "";
        }
    };


    /*
    * add line,bar,dot and any other custom charts using this function
    * in methods object , you must provide the draw function
    *
    * bind Method addChart to Class Chart as a static function
    * */
    Chart.addChart = function (name, methods) {
        /*
        * @param name{String} chart name , identity
        * @param methods{Object} chart methods and at least contains draw function
        *
        * the charts config options will be parsed in the Chart options using key name that matches the param name
        * for example :
        *   the line chart is added using Chart.addChart("line",{})
        *   and the line config options is in the Chart options {line:{..}}
        *
        * */

         //cache the methods in the local charts object and will be called when drawing charts
         charts[name] = methods;
    };
    Chart.charts = charts;

    /*Chart End*/

    /*Class Series Begin*/

    var Series = function (data) {
        /*
         * init the series object which deal with the data
         * data can be Array or Object and format like :
         * [number,number,....] or [{},...] or [[number,..],..]
         * or {name:data,name:data,.....}
         *
         * all the above will be convert to
         * [{data:(number or array or object),name:(if has)},....]
         * and save as series property
         *
         * */
        var series = []
        if (isArray(data)) {
            data.forEach(function (d, i) {
                if (isArray(d)) {
                    series.push({data:d});
                }
                else if (isObject(d)) {
                    //item is {}
                    if (d.data !== undefined) {
                        // item in format {data:something,otherThings...}
                        series.push(d);
                    } else {
                        //item is data
                        series.push({data:d});
                    }
                } else {
                    series.push({data:d});
                }
            })
        } else if (isObject(data)) {
            for (var o in data) {
                series.push({
                    name:o,
                    data:data[o]
                });
            }
        } else {
            series.push({data:data});
        }
        this.series = series;

        //whether accumulate when range calculation
        this.accumulation = false;

    };
    Series.prototype = {
        constructor:Series,
        getRange:function (arr) {
            /*
             * get the max and min value of data
             * return Object
             * {
             *     max:
             *     min:
             * }
             * */
            var series = this.series,
                accumulation = this.accumulation,
                max , min;

             if(!arr){
                //it means all data
                arr = [];
                this.series.forEach(function(s,i){
                    arr.push(i);
                });
            }
            arr.forEach(function (index) {
                //get the max and min value depends on the data format
                var d = series[index].data
                if (isArray(d)) {
                    var iMax = Math.max.apply(Math, d),
                        iMin = Math.min.apply(Math, d);
                    (max === undefined || iMax > max) && (max = iMax);
                    (min === undefined || iMin < min) && (min = iMin);
                } else if (isObject(d)) {
                    for (var o in d) {
                        (max === undefined || d[o] > max) && (max = d[o]);
                        (min === undefined || d[o] < min) && (min = d[o]);
                    }
                } else {
                    (max === undefined || d > max) && (max = d);
                    (min === undefined || d < min) && (min = d);
                }
            });
            if (accumulation) {
                //accumulate max
                var ac
                arr.forEach(function (index, j) {
                    var d = series[index].data;
                    if (isArray(d)) {
                        ac = ac || [];
                        d.forEach(function (value, i) {
                            ac[i] === undefined ? ac[i] = value : ac[i] += value;
                        });
                    } else if (isObject(d)) {
                        ac = ac || {};
                        for (var o in d) {
                            ac[o] === undefined ? ac[o] = d[o] : ac[o] += d[o];
                        }
                    } else {
                        ac = ac || [];
                        ac[j] = d;
                    }
                });
                if (isArray(ac)) {
                    max = Math.max.apply(Math, ac);
                } else if (isObject(ac)) {
                    max = undefined;
                    for (var o in ac) {
                        (max === undefined || ac[o] > max) && (max = ac[o]);
                    }
                }
            }

            return {
                max:max,
                min:min
            }
        },
        getSeries:function () {
            return this.series;
        },
        getLabels:function () {
            /*
             * return labels for auto generated x Axis
             * labels depends on the data
             * so sometimes labels will be array of empty string
             * */

            var labels = [],
                _labels = {},
                isObj = false,
                isArr = false,
                len = 0
            this.series.forEach(function (item) {
                if (item.name && Venus.util.isNumber(item.data)) {
                    //if there is 'name',then use the name
                    labels.push(item.name)
                }
                else {
                    var data = item.data;
                    if (isArray(data)) {
                        //if data is array ,that means got no labels
                        isArr = true;
                        len = Math.max(data.length, len)
                    }
                    else if (isObject(data)) {
                        for (var o in data) {
                            //cache the labels in the object _labels first , this will avoid duplicated labels
                            //and later will convert it to array
                            isObj = true;
                            _labels[o] = true;
                        }
                    } else {
                        labels.push('');
                    }
                }
            });
            if (isObj) {
                //convert _labels to array
                labels = [];
                for (var o in _labels) {
                    labels.push(o);
                }
            }
            if (isArr) {
                // data is Array ,create an array of empty string,length = len
                labels = new Array(len);
                // DON'T USE forEach , it won't work here
                for (var i = 0; i < len; i++) {
                    labels[i] = ''
                }
            }
            return labels;
        },
        getLength:function(){
            /*
            * get data length
            * */
            var length = 0,
                series = this.series;
            if (series.length) {
                if (util.isNumber(series[0].data)) {
                    length = series.length;
                } else if (util.isArray(series[0].data)) {
                    var l = [];
                    series.forEach(function (i) {
                        l.push(i.length);
                    });
                    length = Math.max.apply(Math, l);
                } else if (util.isObject(series[0].data)) {
                    var l = [], o;
                    series.forEach(function (s, i) {
                        l[i] = 0;
                        for (o in s.data) {
                            l[i]++;
                        }
                    });
                    length = Math.max.apply(Math, l);
                }
            }
            return length;
         }
    }

    /*Class Series End */


    /*Class Axis Begin*/

    var Axis = function (options, series, paper) {
        var defaultOptions = {
            percent:0.8,            //length of the axis , percent of svg
            total:0,                //how many ticks to be shown
            max:0,
            min:0,
            tickSize:0,             //tick size in value , optional
            tickWidth:0,            //tick size in pixel , optional
            ticks:[],               //ticks
            rotate:0,               //rotate 0-360 in counter-clockwise
            pop:0,                  // empty ticks before
            opposite:false,
            _svgWidth:0,
            _svgHeight:0,
            _name:'',
            type:CONTINUOUS,      //default type is continuous (discrete,datetime)
            toFormat:"",
            fromFormat:"",
            labelRotate:0,          //rotate 0-360 of the labels in clockwise
            labelPosition:UNDER_TICK, //label is under the tick , otherwise in the center of two ticks
            enable:true,            //visible or not
            fontSize:12             //label font size
        };

        this.options = mix(defaultOptions, options || {});

        this.implement(this.options.type);

        this.name = this.options._name;

        this.stage = paper;

        this.events = new Venus.util.CustomEvent();

        this.model = {};
        this.view = {};
        this.events = new util.CustomEvent();

        this.autoModel();

    }

    Axis.prototype = {
        constructor:Axis,
        autoModel:function () {
            /*
             * auto compute visible ticks ,according to width ,origin ticks , data and so on
             * model got key attribute below
             * {
             *     max,
             *     min,
             *     total,
             *     ticks,
             *     tickSize,
             *     tickWidth,
             *     totalWidth,
             *     pop,
             *     rotate,
             * }
             * */

            // override by each type axis
         },
        set:function(key,value){
            /*
            * set model options
            * */
            var change = false;
            if (isObject(key)) {
                for (var o in key) {
                    if(!key.hasOwnProperty(o)){
                        continue;
                    }
                    if (this.options[o] != key[o]) {
                        this.options[o] = key[o];
                        change = true;
                    }
                }
            } else {
                if (this.options[key] !== value) {
                    this.options[key] = value;
                    change = true;
                }
            }

            if(change){
                this.autoModel();
            }

            if (change && this.axisRendered) {
                this.render();
                this.events.fire('model_change',this.model);
            }

         },
        autoRange:function (min, max, totalTick) {
            /*
             * generate axis ticks according to min and max
             *
             * */
            (min === undefined || min===null || isNaN(min)) && (min = 0);
            (max === undefined || max===null || isNaN(max)) && (max = 10);
            var iDelta = max - min,
                iExp,
                iMultiplier,
                dSolution ,
                dMultiCal,
                dInterval,
                start, end;

            totalTick = totalTick || 5;

//            if (iDelta < 1) { //Modify this by your requirement.
//                max += ( 1 - iDelta) / 2;
//                min -= ( 1 - iDelta) / 2;
//            }
//            iDelta = max - min;
            if(iDelta==0){
                if(min==0 && max==0){
                    return {
                        min:0,
                        max:10,
                        total:2,
                        step:10
                    }
                }
                return {
                    max:max,
                    min:max - Math.abs(max),
                    total:2,
                    step: Math.abs(max)
                }
            }

            iExp = parseInt(Math.log(iDelta) / Math.log(10)) - 2;
            iMultiplier = Math.pow(10, iExp);
            dSolution = [1, 2, 2.5, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000,5000];
            for (var i = 0, l = dSolution.length; i < l; i++) {
                dMultiCal = iMultiplier * dSolution[i];
                if ((parseInt(iDelta / dMultiCal) + 1) <= totalTick) {
                    break;
                }
            }
            dInterval = iMultiplier * dSolution[i];

           // start = (Math.ceil(min / dInterval) - 1) * dInterval;
            start = Math.abs(min) == dInterval ? ( min - dInterval) : util.number.multiple(Math.floor(min / dInterval) ,dInterval);
            for (i = 0; 1; i++) {
                if (start + dInterval * i > max)
                    break;
                end = util.number.add(start, dInterval * (i + 1));
            }


            return {
                max:end,
                min:start,
                step:dInterval,
                total:Math.round((end - start) /dInterval ) + 1
            }
        },
        render:function(){
            var view  = this.view,
                model = this.model,
                stage = this.stage,
                opt = this.options,
                pathAttr = {
                    'opacity':.8,
                    'stroke-width':1
                },
                pathString = [],
                beginX = model.beginX,
                beginY = model.beginY,
                tickHeight = 2,
                labelMarginTop = 5,
                label,
                bbox,
                skip,//if label text is too wide , skip some
                noOppositeLabel = (( model.rotate == 0  ) !== opt.opposite),
                reverse = !!model.reverse,
                transformString = "";

            if (!view.axisElement) {
                view.axisElement = stage.path();
            }
            if (view.tickElements) {
                view.tickElements.forEach(function (t) {
                    t.remove();
                });
                view.tickElements.clear();
            } else {
                view.tickElements = stage.set();
            }
            if (view.labelElements) {
                view.labelElements.forEach(function (label) {
                    label.remove();
                });
                view.labelElements.clear();
            } else {
                view.labelElements = stage.set();
            }

            pathString.push('M', beginX, beginY, 'h', model.totalWidth);

            this.forEach(function (i, length, text) {
                if (i !== 0) {
                    view.tickElements.push(stage.path().attr({
                        path:['M', beginX + length, beginY, 'v', tickHeight]
                    }).attr(pathAttr));
                }
                if (text!==undefined && (!skip || skip <= 1 || (i - model.pop) % skip == 0 )) {
                    var distance = (opt.labelPosition == UNDER_TICK ? 0 : model.tickWidth / 2);
                    label = stage.text(reverse ? (beginX + model.totalWidth - length + distance) : (beginX + length - distance), beginY, text).attr({
                        'font-size':this.options.fontSize
                    });
                    view.labelElements.push(label);
                    bbox = label.getBBox();
                    var line = Math.sqrt(Math.pow(bbox.width, 2) + Math.pow(bbox.height, 2)),
                        totalRotate = ((opt.labelRotate || 0) + (model.rotate || 0)) * PI / 180,
                        t = Math.max(bbox.height, line * Math.cos(totalRotate));
                    skip = Math.ceil((t + 20) / model.tickWidth);
                }

            });

            view.axisElement.attr({
                path:pathString
            }).attr(pathAttr);

            if (model.rotate) {
                //rotate the axis
                transformString += ('R' + (- model.rotate) + ',' + beginX + ',' + beginY);
            }

            if (transformString) {
                //do the transform
                view.axisElement.transform(transformString);
                view.tickElements.transform(transformString);
            }
            view.labelElements.forEach(function (l) {
                var str = "",
                    bBox = l.getBBox(),
                    line = Math.sqrt(Math.pow(bBox.width, 2) + Math.pow(bBox.height, 2)),
                    totalRotate = ((opt.labelRotate || 0) + (model.rotate || 0))*PI/180,
                    t = (Math.max(bBox.height, line * Math.sin(totalRotate)) / 2 + labelMarginTop) * (noOppositeLabel ? 1 : -1);


                if (model.rotate) {
                    str += ("R90");
                }
                if (opt.labelRotate) {
                    str += ( "...R" + opt.labelRotate );
                }
                str += ('T0,'+t);

                if (model.rotate) {
                    str += ("...R-90," + beginX + "," + beginY);
                }

                if (str) {
                    l.transform(str);
                }
            });

            if (!this.options.enable) {
                //if invisible ,hide the elements
                //but the coordinate is actually exist
                view.axisElement.hide();
                view.labelElements.hide();
                view.tickElements.hide();
            }
        },
        on:function(fn){
            this.events.on('model_change',fn);
        },
        implement:function(type){
            if (Axis.types[type]) {
                for (var m in Axis.types[type]) {
                    this[m] = Axis.types[type][m];
                }
            }
        }
    };
    Axis.types = {
        'continuous':{
            autoModel:function(){
                var opt = this.options,
                    model = this.model,
                    alpha = Math.atan(opt._svgHeight / opt._svgWidth),
                    beta = (opt.rotate || 0) * PI / 180,
                    percent = opt.percent,
                    maxWidth = beta <= alpha ? opt._svgWidth / Math.cos(beta) : opt._svgHeight / Math.sin(beta);

                model.pop = opt.pop || 0;
                model.rotate = opt.rotate;

                //got min and max
                var range = this.autoRange(opt.min, opt.max, opt.total);
                model.max = range.max;
                model.min = range.min;
                model.tickSize = range.step;
                model.desc = range.desc;

                model.total = range.total;

                model.tickWidth = opt.tickWidth || maxWidth * percent / (model.total + model.pop - 1);
                model.totalWidth = model.tickWidth * (model.total + model.pop - 1);
            },
            getPoint:function (value) {
                var model = this.model,
                    length;
                length = value === undefined ? 0 : (value - model.min) * model.tickWidth / model.tickSize + model.pop * model.tickWidth;
                return {
                    length:length,
                    tick:value
                }
            },
            forEach:function(fn){
                var model = this.model,
                    distance,
                    i , l,
                    count = 0;

                for (i = 0, l = model.pop; i < l; i++) {
                    fn.call(this, i, (i + 1) * model.tickWidth)
                }
                for (i = model.min, l = model.max; i <= l;) {
                    distance = (count + model.pop) * model.tickWidth;
                    fn.call(this, model.pop + count, distance,l>=1000&& i / 100 === parseInt(i / 100) && i !== 0 ? i / 1000 + 'k' : i);
                    i = util.number.add(i, model.tickSize);
                    count++;
                }
            }
        },
        'discrete': {
            autoModel:function () {
                var opt = this.options,
                    model = this.model,
                    alpha = Math.atan(opt._svgHeight / opt._svgWidth),
                    beta = (opt.rotate || 0) * PI / 180,
                    percent = opt.percent,
                    maxWidth = beta <= alpha ? opt._svgWidth / Math.cos(beta) : opt._svgHeight / Math.sin(beta),
                    total, i, l;

                model.pop = opt.pop || 0;
                model.rotate = opt.rotate;

                //got ticks and generate the visible ticks
                if (opt.tickSize) {
                    model.tickSize = opt.tickSize;
                } else {
                    //compute the tickSize
                    if (opt.total) {
                        total = Math.min(opt.total, opt.ticks.length);
                    } else {
                        total = opt.ticks.length;
                        while (total) {
                            if (opt.fontSize * (total + model.pop) > maxWidth * percent) {
                                total = Math.floor(total / 2);
                            } else {
                                break;
                            }
                        }
                    }
                    if (total == 1) {
                        total = 2;
                        model.pop = 1;
                    }
                    model.tickSize = Math.ceil((opt.ticks.length - 1) / (total - 1)) || 1;
                }
                total = Math.ceil((opt.ticks.length - 1) / model.tickSize) + 1;
                model.tickWidth = parseInt(opt.tickWidth || maxWidth * percent / (total + model.pop - 1));
                model.totalWidth = model.tickWidth * (total + model.pop - 1);
                model.total = total;
            },
            getPoint:function (key) {
                var tick, length,
                    model = this.model,
                    options = this.options

                if (key === undefined) {
                    length = 0;
                } else {
                    if (typeof key == "string") {
                        tick = key;
                        options.ticks.forEach(function (tick, i) {
                            if (tick == key) {
                                key = i;
                            }
                        });
                    } else {
                        tick = options.ticks[key];
                    }
                    length = key * model.tickWidth / model.tickSize + model.pop * model.tickWidth;
                }

                return {
                    length:length,
                    tick:tick
                }
            },
            forEach:function(fn){
                var model = this.model,
                    opt = this.options,
                    distance,
                    i , l,
                    count = 0;

                for (i = 0, l = model.pop; i < l; i++) {
                    fn.call(this, i, (i + 1) * model.tickWidth)
                }
                for (i = 0, l = opt.ticks.length - 1; i <= l;) {
                    distance = (count + model.pop) * model.tickWidth
                    fn.call(this, model.pop + count, distance, opt.ticks[i]);
                    i = util.number.add(i, model.tickSize);
                    count++;
                }
            }
        },
        'datetime':{
            autoModel:function(){
                Axis.types.continuous.autoModel.call(this);

            },
            autoRange:function (a, b) {
                var min = a ? (+a) : ( +new Date()) ,
                    max = b ? (+b) : ( +new Date()) ,
                    iDelta = max - min,
                    step,
                    total,
                    desc,
                    aSecond = 1000,
                    aMinute = 60 * aSecond,
                    aHour = 60 * aMinute,
                    aDay = 24 * aHour,
                    minTime = new Date(min),
                    maxTime = new Date(max);


                if (iDelta == 0) {
                    return {
                        max:max,
                        min:0,
                        step:max,
                        total:2
                    }
                } else if (iDelta < aSecond * 2) {
                    //within 2 seconds
                } else if (iDelta < aMinute * 2) {
                    //within 2 minutes
                    min = minTime.setMilliseconds(0);
                    max = maxTime.getMilliseconds() === 0 ? max : maxTime.setSeconds(maxTime.getSeconds() + 1);
                    step = aSecond;
                    desc = "second";
                    total = (max - min) / step + 1;
                } else if (iDelta < aHour * 2) {
                    //within 2 hours
                    min = minTime.setSeconds(0, 0);
                    max = +(new Date(max).setSeconds(0, 0)) < max ? maxTime.setMinutes(maxTime.getMinutes() + 1,0,0) : max;
                    step = aMinute;
                    desc = "minute";
                    total = (max - min) / step + 1;
                } else if (iDelta < aDay * 2) {
                    //within 2 days
                    min = minTime.setMinutes(0, 0, 0);
                    max = +(new Date(max).setMinutes(0, 0, 0)) < max ? maxTime.setHours(maxTime.getHours() + 1,0,0,0) : max;
                    step = aHour;
                    desc = "hour";
                    total = (max - min) / step + 1;
                } else if (new Date(min).setMonth(minTime.getMonth()+2) > max) {
                    //within 2 month
                    min = minTime.setHours(0, 0, 0, 0);
                    max = +(new Date(max).setHours(0, 0, 0, 0)) < max ? +new Date(maxTime.getFullYear(), maxTime.getMonth(), maxTime.getDate() + 1) : max;
                    step = aDay;
                    desc = "day";
                    total = (max - min) / step + 1;
                } else if (new Date(min).setFullYear(minTime.getFullYear()+2)> max) {
                    //within 2 years
                    min = +new Date(minTime.getFullYear(), minTime.getMonth(), 1);
                    max = +new Date(maxTime.getFullYear(), maxTime.getMonth()) < maxTime ? +new Date(maxTime.getFullYear(), maxTime.getMonth() + 1) : maxTime;
                    minTime = new Date(min);
                    maxTime = new Date(max);
                    desc = "month";
                    //no step because each month has different days
                    total = (maxTime.getFullYear() - minTime.getFullYear()) * 12 + maxTime.getMonth() - minTime.getMonth() + 1;
                } else {
                    // more than two years
                    min = +new Date(minTime.getFullYear());
                    max = +new Date(maxTime.getFullYear(), 0) < maxTime ? +new Date(maxTime.getFullYear() + 1) : maxTime;
                    minTime = new Date(min);
                    maxTime = new Date(max);
                    desc = "year";
                    total = maxTime.getFullYear() - minTime.getFullYear() + 1;
                }
                return {
                    max:max,
                    min:min,
                    step:step,
                    total:total,
                    desc:desc
                }

            },
            getPoint:function (date) {
                var value = +util.date.parse(date),
                    model = this.model,
                    length;
                length = value === undefined ? 0 : (value - model.min) * (model.totalWidth - model.pop * model.tickWidth) / (model.max - model.min) + model.pop * model.tickWidth;
                return {
                    length:length,
                    tick: util.date.format(new Date(value),this.options.toFormat)
                }
            },
            forEach:function(fn){
                var model = this.model,
                    distance,
                    format,
                    i , l,
                    count = 0,
                    date,
                    monthMap = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

                for (i = 0, l = model.pop; i < l; i++) {
                    fn.call(this, i, (i + 1) * model.tickWidth)
                }
                if (model.tickSize) {
                    switch(model.desc){
                        case "second":
                            format = "ss";
                            break;
                        case "minute":
                            format = "mm:ss";
                            break;
                        case "hour":
                            format = "hh:mm";
                            break;
                        case "day":
                            format = "MM-dd";
                            break;
                    }
                    //got tickSize , means tickSize< month
                    for (i = model.min, l = model.max; i <= l;) {
                        distance = (count + model.pop) * model.tickWidth;
                        fn.call(this, model.pop + count, distance, util.date.format(i, format));
                        i = util.number.add(i, model.tickSize);
                        count++;
                    }
                } else {
                    //month or year
                    date = new Date(model.min);
                    if (model.desc == "month") {
                        while (+date <= model.max) {
                            distance = this.getPoint(date).length;
                            fn.call(this, model.pop + count, distance, monthMap[date.getMonth()]);
                            date = new Date(date.setMonth(date.getMonth() + 1));
                            count++;
                        }
//                        for (i = model.min, l = model.max; i <= l;) {
//                            distance = this.getPoint(date);
//                            fn.call(this, model.pop + count, distance, monthMap[date.getMonth()]);
//                            i = util.number.add(i, model.tickSize);
//                            count++;
//                        }
                    } else if (model.desc == "year") {
                        while (+date <= model.max) {
                            distance = (count + model.pop) * model.tickWidth;
                            fn.call(this, model.pop + count, distance, date.getFullYear());
                            date = new Date(date.setFullYear(date.getFullYear() + 1));
                            count++;
                        }
                    }
                }

            }
        }
    };

    Axis.extendType = function(type,methods){
        Axis.types = methods;
    };


    /*Class Axis End*/


    /*Class Legend Begin*/

    var Legend = function (chart, options, paper) {
        /*
         * Class Legend
         * @param series{Series} instance of Series
         * @param options{Object}
         * @param paper{Raphael} instance of Raphael
         *
         * */
         var defaultOption = {
                position:['right', 'top'],  //position of the legend contains two elements (horizontal and vertical) each could be string and number
                format:'{name}',            //format of the texts
                fontSize:12,                //text font size
                colors:[],                  //colors ,parsed as the dpchart.colors
                borderWidth:.8,
                borderColor:'gray',
                direction:'vertical'       //how to layout the items
            }, i, l
            , series = chart.series
            , data = series.getSeries()
            , width = 15                        //item width
            , lineHeight = 20                   // item line height
            , span = 10                         //distance between item and text
            , border                            // rect element of border
            , startX = 0
            , startY = 0
            , item
            , icon
            , text
            , textWidth
            , totalWidth
            , totalHeight
            , itemSet                           // set of items
            , textSet                           // set of texts
            , margin = 10                       // margin to svg boundary
            , padding = 10
            , names
            , colors
            , isVertical, _x,_y ,
            left , top,
            active, activeEvent, activeArray,
            self = this,
            opt = this.options = mix(defaultOption, options);

        //Raphael Set to contain the elements
        itemSet = paper.set();
        textSet = paper.set();

        colors = opt.colors;

        names = options.names;

        //vertical or horizontal
        isVertical = (opt.direction == 'vertical');

        //used to compute the total width
        isVertical ? totalWidth = [] : totalWidth = 0;

        startX = padding;
        startY = padding;

        for (i = 0, l = data.length; i < l; i++) {
            //create the raphael elements
            _x = startX;
            _y = startY;
            icon = chart.iconFactory.create(i, _x+width/2, _y+lineHeight/2, width);
            item = icon.icon;
            item._iconObj = icon;

            text = paper.text(_x + width + span, _y + lineHeight/ 2, names[i]).attr({
                'font-size':opt.fontSize
            });

            textWidth = text.getBBox().width;
            text.translate(textWidth / 2, 0);

            isVertical ? startY += lineHeight : startX += (width + span * 2 + textWidth);

            item.attr({
                'fill':colors[i],
                'stroke-width':0,
                'cursor':'pointer'
            });
            itemSet.push(item);
            textSet.push(text);
            isVertical ? totalWidth.push(textWidth) : totalWidth += textWidth;
        }
        totalWidth = isVertical ? Math.max.apply(Math, totalWidth) + width + span + padding * 2 : width * l + (2 * l - 1) * span + padding * 2 + totalWidth;
        totalHeight = isVertical ? lineHeight * l + padding * 2 : padding * 2 + lineHeight;

        //border
        var _lastX,_lastY;
        border = paper.rect(0, 0, totalWidth, totalHeight, 5).attr({
            'stroke-width':opt.borderWidth,
            'stroke':opt.borderColor,
            'fill':"#FFF",
            'cursor':'move'
        }).drag(function(dx,dy){
                var shiftX = dx - _lastX,
                    shiftY = dy - _lastY;
                self.setPosition(shiftX,shiftY);
                _lastX = dx;
                _lastY = dy;
            },function(){
                _lastX = 0;
                _lastY = 0;
                self.toFront();
            });


        this.border = border;
        this.itemSet = itemSet;
        this.textSet = textSet;

        this.toFront();

        //convert position string to value
        if (typeof (left = this.options.position[0]) == "string") {
            if (left == "right") {
                left = this.options._svgWidth - totalWidth - margin;
            } else if (left == "center") {
                left = this.options._svgWidth / 2 - totalWidth / 2
            } else {
                left = margin
            }
        }

        if (typeof (top = this.options.position[1]) == "string") {
            if (top == "bottom") {
                top = this.options._svgHeight - totalHeight - margin
            } else if (top == 'center') {
                top = this.options._svgHeight / 2 - totalHeight / 2
            } else {
                top = margin
            }
        }

        this.setPosition(left, top);

        //init active , all is active
        active =  this.active = [];
        itemSet.forEach(function(){
            active.push(true);
        });
        activeArray = this.activeArray = active.slice(0);
        activeEvent =  this.activeEvent = new util.CustomEvent();


        //bind default click event
        this.on('click', function (e, i) {
            active[i] ? active[i] = false : active[i] = true;
            active[i] ? this.attr('fill', colors[i]) : this.attr('fill', 'gray');
            activeArray = self.activeArray = [];
            active.forEach(function(truth,index){
                truth && activeArray.push(index);
            });
            activeEvent.fire('change', active,activeArray);
        });
    };
    Legend.prototype = {
        constructor:Legend,
        setPosition:function (left, top) {
            //set the position of the legend
            //relative ,not absolute
            this.itemSet.translate(left, top);
            this.textSet.translate(left, top);
            this.border.translate(left, top);
        },
        on:function (name, fn) {
            //bind DOM Events on legend item
            var event;
            if ((event = this.itemSet[name] ) && util.isFunction(event)) {
                //has function such as click, mouseover
                this.itemSet.forEach(function (item, i) {
                    item[name](function (e) {
                        fn.call(item, e, i);
                    });
                })
            }
            return this;
        },
        onActiveChange:function (fn) {
            this.activeEvent.on('change', fn);
        },
        toFront:function(){
            this.border.toFront();
            this.itemSet.toFront();
            this.textSet.toFront();
        }
    }

    /*Class Legend End*/


    /*Class Grid Begin*/

    var Grid = function (options, paper) {
        var defaultOption = {
                'color':'#ccc', //color of the grid
                'rows':[], //coordinate
                'columns':[],
                'width':0, //length of the row
                'height':0, //length of the column
                'stroke-width':1,
                'opacity':0.2,
                _x:0, //x coordinate of y axis
                _y:0                    //y coordinate of x axis ,these are used as the start position
            };
        this.options = mix(defaultOption, options);
        this.paper = paper;
        this.rows = paper.set();
        this.columns = paper.set();
        this.render();
    }
    Grid.prototype = {
        constructor:Grid,
        render:function(){
            this.rows.forEach(function(r){
                r.remove();
            }).clear();
            this.columns.forEach(function(c){
                c.remove();
            }).clear();

            var options = this.options,
                paper = this.paper,
                lineAttr = {
                stroke:options.color,
                "stroke-width":options['stroke-width'],
                'opacity':options.opacity
                },self = this;

            if (options.rows && options.rows.length) {
                //draw rows
                options.rows.forEach(function (value) {
                    self.rows.push(paper.path('M' + options._x + "," + value + "h" + options.width).attr(lineAttr));
                });
                self.rows.toBack();
            }
            if (options.columns &&options.columns.length) {
                //draw columns
                options.columns.forEach(function (value) {
                    self.columns.push(paper.path('M' + value + "," + options._y + "v" + -options.height).attr(lineAttr));
                });
                self.columns.toBack();
            }
        }
    }

    /*Class Grid End*/

    var Threshold = function(axisName,value,coordinate,stage){
        this.axisName = axisName;
        this.stage = stage;
        this.axis = coordinate.axises[axisName];
        this.type = coordinate.type(axisName);
        this.value = value;
        this.coordinate = coordinate;
        this.render();
    }
    Threshold.prototype = {
        constructor:Threshold,
        render:function(){
            var width,
                coordinate = this.coordinate,
                triangleWidth = 10,
                pos = this.getPosition(this.value);

            width = this.type=='x'? coordinate.y.model.totalWidth: coordinate.x.model.totalWidth;
            this.line = this.stage.path().attr({
                path:['M', pos.x, pos.y, 'v', -triangleWidth / 2, 'l', triangleWidth, triangleWidth / 2, 'h', width - triangleWidth, 'm', triangleWidth - width, 0, 'l', -triangleWidth, triangleWidth / 2, 'v', -triangleWidth / 2],
                'fill':'red',
                'stroke':'red'
            });

        },
        moveTo:function(value){

        },
        getPosition:function(value){
            var coordinate = this.coordinate,
                x = coordinate.xName,
                y = coordinate.yName,
                xy;

            if(this.type==="x"){
                coordinate.use(this.axisName,y);
                xy = coordinate.get(value);
                coordinate.use(x,y);
                return {
                    x:xy.x,
                    y:xy.y
                }

            }else{
                coordinate.use(x,this.axisName);
                xy = coordinate.get(undefined,value);
                coordinate.use(x,y);
                return {
                    x:xy.x,
                    y:xy.y
                }
            }
        }
    }




    /*
        extends Raphael Element , toolTip function
    */
    var toolTip = function (paper, x, y, texts, side) {
            //extend the Raphael Element and provide the toolTip Function
            //@param x , y position of the tip
            //@texts{Array or String} each line of text
            //@side{String} 'left','top','right' or 'bottom'
            var tip, labels,
                side = side || 'top',
                path = function (width, height, padding,side) {
                    var p = [],
                        arrowWidth = 5,
                        left, top;

                    height += (2 * padding || 0);
                    width += (2 * padding || 0);
                    switch (side) {
                        case 'right':
                            //arrow at the left side and content at right
                            height = Math.max(arrowWidth * 2, height);
                            p.push('M', x + 10, y);
                            p.push('l', arrowWidth, -arrowWidth);
                            p.push('v', -(height / 2 - arrowWidth));
                            p.push('h', width);
                            p.push('v', height, 'h', -width);
                            p.push('v', -(height / 2 - arrowWidth));
                            p.push('l', -arrowWidth, -arrowWidth);
                            left = x + 10 + arrowWidth;
                            top = y - height / 2;
                            break;
                        case 'top':
                            width = Math.max(arrowWidth * 2, width);
                            p.push('M', x, y - 10);
                            p.push('l', -arrowWidth, -arrowWidth);
                            p.push('h', -(width / 2 - arrowWidth));
                            p.push('v', -height, 'h', width, 'v', height);
                            p.push('h', -(width / 2 - arrowWidth));
                            p.push('l', -arrowWidth, arrowWidth);
                            left = x - width / 2;
                            top = y-10 - arrowWidth - height;
                            break;
                        case 'left':
                            height = Math.max(arrowWidth * 2, height);
                            p.push('M', x - 10, y);
                            p.push('l', -arrowWidth, arrowWidth);
                            p.push('v', height / 2 - arrowWidth);
                            p.push('h', -width, 'v', -height, 'h', width);
                            p.push('v', height / 2 - arrowWidth);
                            p.push('l', arrowWidth, arrowWidth);
                            left = x-10 - arrowWidth - width;
                            top = y - height / 2;
                            break;
                        case 'bottom':
                            width = Math.max(arrowWidth * 2, width);
                            p.push('M', x, y + 10);
                            p.push('l', arrowWidth, arrowWidth);
                            p.push('h', width / 2 - arrowWidth);
                            p.push('v', height, 'h', -width, 'v', -height);
                            p.push('h', width / 2 - arrowWidth);
                            p.push('l', arrowWidth, -arrowWidth);
                            left = x - width / 2;
                            top = y+10 + arrowWidth;
                            break;

                    }
                    p.push('z');
                    return {
                        path:p,
                        box:{
                            left:left,
                            top:top,
                            width:width,
                            height:height
                        }
                    };
                }

            !isArray(texts) && (texts = [texts]);
            labels = paper.set();
            var width = [], height = 0,
                bBox,
                text,
                paddingToBorder = 8,
                p,
                totalWidth,totalHeight;


            texts.forEach(function (t, i) {
                text = paper.text(x, -100, t);
                labels.push(text);
                bBox =util.clone(text.getBBox());
                //seems Raphael's bug , when contains 
                bBox.width += (t.toString().split(' ').length * 10)

                text.attr({
                    'opacity':0,
                    'font-size':12
                });
                width.push(bBox.width);
            });
            if (this._venus_tooltip_show)
                return;

            totalWidth = Math.max.apply(Math, width);
            totalHeight = texts.length * bBox.height;

            p = path(totalWidth, totalHeight, paddingToBorder,side);
            //if the tip is out of bound
            if (p.box.left + p.box.width > paper.canvas.clientWidth) {
                p = path(totalWidth, totalHeight, paddingToBorder, 'left');
            } else if (p.box.left < 0) {
                p = path(totalWidth, totalHeight, paddingToBorder, 'right');
            } else if (p.box.top < 0) {
                p = path(totalWidth, totalHeight, paddingToBorder, 'bottom');
            } else if (p.box.top + p.box.height > paper.canvas.clientHeight) {
                p = path(totalWidth, totalHeight, paddingToBorder, 'top');
            }
            tip = paper.path();
            labels.toFront();
            tip.attr({
                path:p.path,
                fill:"#FFF",
                "stroke-width":2,
                "fill-opacity":.1,
                'stroke-linejoin':'round',
                'stroke':'#4572A7',
                'opacity':'0'
            });
            tip.animate({'opacity':1, 'fill-opacity':.85}, 100);
            labels.animate({'opacity':1}, 100);
            labels.forEach(function (la, i) {
                la.attr({
                    'y':p.box.top + (i + .5) * bBox.height + paddingToBorder,
                    'x':p.box.left + p.box.width / 2
                })
            });
            this._venus_tooltip_labels = labels;
            this._venus_tooltip = tip;
            this._venus_tooltip_show = true;
            return toolTip;
        },
        toolTipHide = function () {
            var self = this,
                cb = function () {
                    this.remove();
                    self._venus_tooltip_show = false;
                }, animate = Raphael.animation({'opacity':0}, 100, 'linear', cb);
            this._venus_tooltip && (this._venus_tooltip.animate(animate) ) && (this._venus_tooltip_labels.animate(animate) );
        };
    Raphael.el.toolTip = toolTip;
    Raphael.el.toolTipHide = toolTipHide;


    //for unit test , temporary bind Classes on Chart
    Chart.Series = Series;
    Chart.Axis = Axis;
    Chart.Legend = Legend;
    Chart.Grid = Grid;

    Venus.SvgChart = Chart;

})(this);


/*
* @change log :
*
*   2012-09-25: version 1.1
*   1. options change:
*       1.1 add 'tooltip' function to config the tooltip
*           {x:String,y:String,label:String} will be parsed to this function
*       1.2 add 'axisUsage' to config which two axises to use
*       1.3 add 'icons' to config which icon to used for each series
*           call this.iconFactory.create to create icons
*       1.4 axis config optimized :
*           tickWidth,tickSize,max,min
*           are now optional
*       1.5 options object now cloned and mix to default options , outer options object stays no change
*
*   2. Class Axis rebuild:
*       2.1 Axis now is separated as model and view
*           model can be changed out of the Axis instance
*           view binds to the model and will auto render when model changes
*           charts now rely on the model , bind to model and auto change when model changes
*           model got some key attributes , see Axis.model
*      2.2 range and ticks are auto computed and also can config in options
*      2.3 remove prototype function getX,getY,getOrigin,setPosition,getAngel,getTicksPos
*      2.4 coordinate service now is provided by Chart.coordinate
*
*   3. Class Series change:
*       3.1 Series.getRange() can receive an array which is indexes of series to get the appointed range of data
*
*   4. Class Legend change:
*       4.1 legend now use iconFactory to create icons
*       4.2 legend now is draggable
*
*   4. Class Grid change:
*       4.1 Grid now are bind to the axis model and re-render when model changes
*
*   5. Chart.coordinate added:
*       4.1 coordinate object manages the axises and provide some services to help draw charts
*       4.2 use coordinate.get(x,y) to replace axis.getX, axis.getY
*
*   6. add _initLabels() in the main drawing flow to provide the labels use by legend , tooltip , axis
*
*   7. add _initIconFactory() in the main drawing flow to init the iconFactory object
*
*   8. charts are bind to the axis model and do some changes when the model change
*
*   9. Line Chart
*      9.1 Line Dot now stays the same as legend both calls iconFactory to create icons
*      9.2 Tip will show when close to dot and add 'hoverRadius' to config the response radius,default to 50
*      9.3 set 'columnHover' default to false since the 'hoverRadius' is on
*      9.4 use mouse event clientX,and clientY to implement columnHover instead of invisible column bars
*
*   10.Bar Chart
*      10.1 bind to axis model
*      10.2 set x axis label and bars between ticks
*
*   11.tooltip
*      11.1 tooltip ui rebuild and fix some bugs
*
* */