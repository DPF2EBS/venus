/*
 * SVG Chart Lib of Venus
 * */

;
(function (global, undefined) {
    /*
     * cache global.Venus to Venus
     * */
    var Venus = global.Venus;

    /* make some global variables local */
    var util = Venus.util
        , mix = util.mix
        , PI = Math.PI
        , isArray = util.isArray
        , isObject = util.isObject
        , getColor = util.getColors

    // charts added  using Venus.SvgChart.addChart
        , charts = {}

        , DEFAULT_Y_AXIS = "y"
        , DEFAULT_X_AXIS = "x";


    /*Chart Begin*/
    /*
     * Class Chart
     * @param container{HTMLElement} container of the svg element to draw the chart
     * @param data{Array,Object} data can be array or object
     * @param options{object}
     *
     *  will bind to Venus.SvgChart later
     */
    function Chart(container, data, options) {
        if (!container || !container.nodeType) {
            //not dom
            return;
        }
        this.container = container;
        this.data = data || [];
        this.events = new Venus.util.CustomEvent();

        //default options
        var defaultOptions = {
            /*
             * width and height  equals the containers width and height by default
             * but when the container is invisible ,please parse the width and height manually
             * */
            width:container.clientWidth,
            height:container.clientHeight,

            /*
             * colors will be auto generated by calling Venus.util.getColors if you don't parse an array
             * */
            colors:[],

            /*
             * axises usually are x and y .
             * actually you can create any numbers of axises
             * For detail see Class Axis
             * */
            axis:{
            },

            /*
            * config each series  which two axises are used as the x and y axis
            *  for example :
            *  axisUsage:{
            *      0:['x','y']
            *      1:['x','y1']
            *  }
            *  x and y axis are used by default
            *
            * */
            axisUsage:{},

            /*
             * grid under the chart has the follow config options:
             * enableRow
             * enableColumn
             * opacity
             *
             * no grid by default
             *
             * for detail , see Class Grid
             * */
            grid:{
                opacity:0.4
            },

            /*
            * config tooltip text
            * tooltip will call this function to get the tooltip text and will parsed in an object
            * obj contains
            * {
            *     x: x axis value
            *     y: y axis value
            *     label: name of this series
            * }
            * */
            tooltip:function (obj) {
               // return obj.label + " " + obj.x + " " + obj.y;
                return obj.y;
            },
            icons:{}
        }, self = this;

        //clone and mix options
        this.options = mix(defaultOptions,util.clone(options)|| {});

        //init raphael
        this.stage = new Raphael(container, this.options.width, this.options.height);

        //new! coordinate object
        this.coordinate = this._initCoordinate();

        //new! icon factory
        this.iconFactory = this._initIconFactory();

        //init events
        this._initEvents();

        //init data
        this._initData();
        this.events.fire('onDataInit', this.series);

        this.colors = this.options.colors && this.options.colors.length ? this.options.colors : getColor(this.series.getSeries().length);

        // init axis
        this._initAxis();
        this.events.fire('onAxisInit', {});

        //init labels
        this._initLabels();

        //init legend
        this._initLegend();
        this.events.fire('onLegendInit', this.legend);

        //init grid
        this._initGrid();
        this.events.fire('onGridInit', this.grid);

        // draw
        this._draw();

        // render axis ui
        this._renderAxis();

        this.events.fire('onFinish');

    }

    /*
    * Prototype of Class Chart
    * */
    Chart.prototype = {
        constructor:Chart,
        _initData:function () {
            this.series = new Series(this.data);
        },
        _initLabels:function(){
            var data = this.series.getSeries(),
                labels = this.series.getLabels(),
                _labels = [],
                self = this,
                coordinate = self.coordinate;

            data.forEach(function (d, j) {
                if (d.name !== undefined) {
                    //if got name , use name
                    _labels.push(d.name);
                } else if (Venus.util.isNumber(d.data)) {
                    //if data is number , use label or x ticks because labels may be empty
                    _labels.push(labels[j] || (coordinate.x && coordinate.x.options.ticks ? coordinate.x.options.ticks[j] || '' : ""));
                } else {
                    //otherwise there's no way to get the names , let it be empty
                    _labels.push('');
                }
            });
            this.labels = _labels;
        },
        _initCoordinate:function () {
            var self = this,
                options = self.options;
            return {

                /*
                 * axises are stored in this object
                 * axises:{
                 *     x:,
                 *     y:,
                 *     x1:,
                 *     y1:,...
                 * }
                 * */
                axises:{},

                /*
                 * add axis
                 * */
                push:function (name, axis) {
                    this.axises[name] = axis
                },


                /*
                 * use two axis to generate the coordinate
                 * */
                use:function (x, y) {
                    this.x = this.axises[x];
                    this.y = this.axises[y];
                },

                /*
                 * use the coordinate generated by 'use' function
                 * returns x and y position in svg
                 * */
                get:function (key, value) {
                    var xOpt = this.x.options,
                        yOpt = this.y.options,
                        xModel = this.x.model,
                        yModel = this.y.model,
                        x, y, xTick, yTick;

                    if (key != undefined) {
                        if (typeof key == "string") {
                            xTick = key;
                            xOpt.ticks.forEach(function (tick, i) {
                                if (tick == key) {
                                    key = i;
                                }
                            });
                        } else {
                            xTick = xOpt.ticks[key];
                        }
                        // x = key*(xModel.totalWidth - xModel.pop* xModel.tickWidth)/(xOpt.ticks.length-1) + xModel.beginX+ xModel.pop* xModel.tickWidth;
                        x = key * xModel.tickWidth / xModel.tickSize + xModel.pop * xModel.tickWidth + xModel.beginX
                    }
                    if (value != undefined) {
                        if (yOpt.ticks && yOpt.ticks.length) {
                            yOpt.ticks.forEach(function (tick, i) {
                                if (tick == value) {
                                    value = i;
                                }
                            });
                            y = yModel.beginY - value * (yModel.totalWidth - yModel.pop * xModel.tickWidth) / (xOpt.ticks.length - 1) - yModel.pop * yModel.tickWidth
                        } else {
                            y = yModel.beginY - ( value - yModel.min) * yModel.tickWidth / yModel.tickSize - yModel.pop * yModel.tickWidth;
                        }
                        yTick = value;
                    }

                    return {
                        x:x,
                        y:y,
                        xTick:xTick,
                        yTick:yTick
                    }
                },


                /*
                 * get which two axises to use
                 *
                 * */
                getAxisUse:function (i) {
                    if (!this.axisUsageArray) {
                        var arr = this.axisUsageArray = [];
                        self.series.getSeries().forEach(function (s, _index) {
                            if (!options.axisUsage || !options.axisUsage[_index]) {
                                arr.push({
                                    x:DEFAULT_X_AXIS,
                                    y:DEFAULT_Y_AXIS
                                });
                            }else{
                                arr.push({
                                    x: options.axisUsage[_index][0] || DEFAULT_X_AXIS,
                                    y:options.axisUsage[_index][1] || DEFAULT_Y_AXIS
                                });
                            }
                        });
                    }
                    return this.axisUsageArray[i];
                }
            };
        },
        _initIconFactory:function () {
            var self = this,
            /*
                * build-in icons for legend , line and others
                * currently contains 'rect','circle','triangle'
                * each icon must extends interfaces below:
                * create{Function} ,receives stage, x, y , width and returns an object contains raphael element, size ,position,animate function
                *          stage is the raphael instance;
                *          x,y is the center of the element;
                *          width is the width of the element;
                * size{Function} , receives the 'width' param and set the width of the element
                * position{Function}, set or get the position of the element, that is the coordinate of the center of the element
                * animate{Function}, delegate raphael element and custom the x,y,width animation
                *
                * */
                nativeIcons = {
                    'rect':{
                        create:function (stage, x, y, width) {
                            return {
                                icon:stage.rect(x - width / 2, y - width / 2, width, width),
                                position:this.position,
                                animate:this.animate,
                                size:this.size
                            }
                        },
                        size:function (w) {
                            this.icon.attr('width', w);
                        },
                        position:function (x, y) {
                            if (arguments.length == 0) {
                                return{
                                    x:this.icon.attr('x') + this.icon.attr('width') / 2,
                                    y:this.icon.attr('y') + this.icon.attr('width') / 2
                                }
                            }
                            this.icon.attr({
                                'x':x,
                                'y':y
                            });
                        },
                        animate:function (obj, duration) {
                            if (obj.x) {
                                obj.x = obj.x - this.icon.attr('width') / 2;
                            }
                            if (obj.y) {
                                obj.y = obj.y - this.icon.attr('width') / 2;
                            }
                            if (obj.width) {
                                obj.height = obj.width;
                                if (!obj.x && !obj.y) {
                                    var icon = this.icon,
                                        delta = obj.width - icon.attr('width');
                                    obj.x = icon.attr('x') - delta / 2;
                                    obj.y = icon.attr('y') - delta / 2;
                                }
                            }
                            this.icon.animate(obj, duration);
                        }
                    },
                    'circle':{
                        create:function (stage, x, y, width) {
                            return {
                                icon:stage.circle(x, y, width / 2),
                                position:this.position,
                                animate:this.animate,
                                size:this.size
                            }
                        },
                        size:function (w) {
                            this.icon.attr('r', w / 2);
                        },
                        position:function (x, y) {
                            if (arguments.length == 0) {
                                return{
                                    x:this.icon.attr('cx'),
                                    y:this.icon.attr('cy')
                                }
                            }
                            this.icon.attr({
                                'cx':x,
                                'cy':y
                            });
                        },
                        animate:function (obj, duration) {
                            for (var o in obj) {
                                if (o == 'x') {
                                    obj.cx = obj[o];
                                } else if (o == 'y') {
                                    obj.cy = obj[o];
                                } else if (o == 'width') {
                                    obj.r = obj[o] / 2;
                                }
                            }
                            delete obj.x;
                            delete obj.y;
                            delete obj.width;
                            this.icon.animate(obj, duration);
                        }
                    }
                },

                /*
                * default icon is rect
                * */
                defaultIcon = 'rect';
            return {
                defaultIcon:defaultIcon,
                icons:self.options.icons,
                create:function (i, x, y, width) {
                    /*
                    * factory function to create an icon element
                    * i{Number}:index
                    * x,y {Number}:position of the center of the element
                    * width{Number}:width of the element
                     * this function will call the build-in icon create function or function parsed in the icons options
                    *
                    * */
                    var iconType = this.icons[i] || defaultIcon;
                    if (typeof iconType === "string") {
                        //if string , call the build-in icons
                        return nativeIcons[iconType].create(self.stage, x, y, width);
                    } else if (util.isObject(iconType)) {
                        //call the icons parsed in the icons options
                        //it must implement the icon interface as build-in icons
                        return  iconType.create(self.stage, x, y, width);
                    }
                },
                nativeIcons:nativeIcons
            }

        },
        _initAxis:function () {
            var opt = this.options,
                axisOption = opt.axis,
                axis,
                thisAxisOption,
                range,
                beginX,
                beginY,
                seriesArray = [],
                thisAxis,
                coordinate = this.coordinate;

            for (axis in axisOption) {
                if (!axisOption.hasOwnProperty(axis)) {
                    continue;
                }
                //init each axis in options.axis
                if ((thisAxisOption = axisOption[axis])) {
                    //set rotate 90 for y axis by default
                    (axis.indexOf('y') == 0 && !('rotate' in thisAxisOption)) && (thisAxisOption.rotate = 90);

                    if (axis.indexOf('y') ==0 && !axisOption.ticks) {
                        //if y axis has no ticks , then auto generate ticks use series.getRange()
                        if (axis == DEFAULT_Y_AXIS) {
                            //is the default y axis
                            this.series.getSeries().forEach(function (s, _index) {
                                if (!opt.axisUsage ||!opt.axisUsage[_index] || opt.axisUsage[_index][1] == axis) {
                                    seriesArray.push(_index);
                                }
                            });
                        }else{
                            this.series.getSeries().forEach(function (s, _index) {
                                if (opt.axisUsage[_index] && opt.axisUsage[_index][1] == axis) {
                                    seriesArray.push(_index);
                                }
                            });
                        }
                        //get range
                        range = this.series.getRange(seriesArray);

                        //set max and min
                        thisAxisOption.max === undefined && (thisAxisOption.max = range.max);
                        thisAxisOption.min === undefined && (thisAxisOption.min = range.min);
                    }
                    if (axis.indexOf('x') == 0) {
                        //set pop=1 for x Axis by default
                        (thisAxisOption.pop === undefined) && (thisAxisOption.pop = 1);

                        (thisAxisOption.percent === undefined) && (thisAxisOption.percent =.9);

                        //if x axis has no ticks , then auto generate ticks use series.getLabels()
                        //but getLabels() sometimes returns array of empty string depends on the data
                        if (!thisAxisOption.ticks) {
                            thisAxisOption.ticks = this.series.getLabels();
                        }
                    }

                    thisAxisOption._svgWidth = this.options.width;
                    thisAxisOption._svgHeight = this.options.height;

                    thisAxis = new Axis(thisAxisOption, this.series, this.stage);
                    coordinate.push(axis, thisAxis);

                    if (axis.indexOf('x') == 0) {
                        beginX = Math.min(beginX || opt.width, (opt.width - thisAxis.model.totalWidth) / 2);
                    } else if (axis.indexOf('y') == 0) {
                        beginY = Math.min(beginY || opt.width, (opt.height - thisAxis.model.totalWidth) / 2);
                    }
                }
            }
            for (axis in coordinate.axises) {
                if (!coordinate.axises.hasOwnProperty(axis)) {
                    continue;
                }
                coordinate.axises[axis].model.beginX = beginX;
                coordinate.axises[axis].model.beginY = opt.height - beginY;
            }
            this.coordinate.use('x', 'y');

            //set this property false
            //and before it is true , set model will not immediately rerender the ui
            //it will be changed to true in _renderAxis method
            this.axisRendered = false;
        },
        _renderAxis:function () {
            var o , axises = this.coordinate.axises;
            for (o in axises) {
                if (axises.hasOwnProperty(o)) {
                    axises[o].axisRendered = true;
                    axises[o].autoModel();
                    axises[o].render();
                }
            }
            this.axisRendered = true;
        },
        _initLegend:function () {
            /*
             * init legend
             * */

            var opt = this.options,
                legendOption = opt.legend,
                coordinate = this.coordinate,
                series = this.series,
                legend;

            if (legendOption && this.series.getSeries().length) {
                //set options for legend
                legendOption._svgWidth = opt.width;
                legendOption._svgHeight = opt.height;
                legendOption.colors = this.colors;
                legendOption.names = this.labels;

                //if there are ticks of x axis , parse to legend for some use
               // this.coordinate.axises.x && this.coordinate.axises.x.options.ticks && ( legendOption._ticks = this.coordinate.axises.x.options.ticks);

                legend = this.legend = new Legend(this, legendOption, this.stage);
                legend.onActiveChange(function (active,activeArray) {
                    if ((!coordinate.y.options.ticks || !coordinate.y.options.ticks.length ) && activeArray.length) {
                        var range = series.getRange(legend.activeArray);
                        coordinate.y.set({
                            min:range.min,
                            max:range.max
                        });
                    }
                });

            }
        },
        _initGrid:function () {
            var gridOption = this.options.grid,
                coordinate = this.coordinate,
                rows = [],columns = [];
            //generate positions of  rows and columns
            function generatePositions() {
                rows = [];
                columns = [];
                if (gridOption.enableRow && coordinate.y) {
                    //use coordinate.y to generate rows
                    coordinate.y.model.ticks.forEach(function (t) {
                        rows.push(coordinate.get(null, t).y);
                    });
                    gridOption.rows = rows;
                    gridOption.height = coordinate.y.model.totalWidth;
                    gridOption._y = coordinate.y.model.beginY;
                }
                if (gridOption.enableColumn && coordinate.x) {
                    coordinate.x.model.ticks.forEach(function (t) {
                        columns.push(coordinate.get(t, null).x);
                    });
                    gridOption.columns = columns;
                    gridOption.width = coordinate.x.model.totalWidth;
                    gridOption._x = coordinate.x.model.beginX;
                }
            }
            generatePositions();

            var grid = this.grid = new Grid(gridOption, this.stage);
            coordinate.y &&coordinate.y.on(function(){
                generatePositions();
                util.mix(grid.options,gridOption);
                grid.options.rows = gridOption.rows;
                grid.options.columns = gridOption.columns;
                grid.render();
            });

        },
        _initEvents:function () {
            var opt = this.options;
            if(opt.events){
                for(var event in opt.events){
                    this.events.on(event, opt.events[event]);
                }
            }
        },
        _draw:function () {
            var chart ,chartOption;
            for (chart in charts) {
                if (chartOption =  this.options[chart]) {
                    //draw each chart in options , so you can put several type of charts in one svg
                    charts[chart].draw && charts[chart].draw.call(this, chartOption);
                }
            }
        },
        destroy:function(){
            this.stage && this.stage.clear();
            this.stage = null;
            this.container.innerHTML = "";
        }
    };


    /*
    * add line,bar,dot and any other custom charts using this function
    * in methods object , you must provide the draw function
    *
    * bind Method addChart to Class Chart as a static function
    * */
    Chart.addChart = function (name, methods) {
        /*
        * @param name{String} chart name , identity
        * @param methods{Object} chart methods and at least contains draw function
        *
        * the charts config options will be parsed in the Chart options using key name that matches the param name
        * for example :
        *   the line chart is added using Chart.addChart("line",{})
        *   and the line config options is in the Chart options {line:{..}}
        *
        * */

         //cache the methods in the local charts object and will be called when drawing charts
         charts[name] = methods;
    };
    Chart.charts = charts;

    /*Chart End*/

    /*Class Series Begin*/

    var Series = function (data) {
        /*
         * init the series object which deal with the data
         * data can be Array or Object and format like :
         * [number,number,....] or [{},...] or [[number,..],..]
         * or {name:data,name:data,.....}
         *
         * all the above will be convert to
         * [{data:(number or array or object),name:(if has)},....]
         * and save as series property
         *
         * */
        var series = []
        if (isArray(data)) {
            data.forEach(function (d, i) {
                if (isArray(d)) {
                    series.push({data:d});
                }
                else if (isObject(d)) {
                    //item is {}
                    if (d.data !== undefined) {
                        // item in format {data:something,otherThings...}
                        series.push(d);
                    } else {
                        //item is data
                        series.push({data:d});
                    }
                } else {
                    series.push({data:d});
                }
            })
        } else if (isObject(data)) {
            for (var o in data) {
                series.push({
                    name:o,
                    data:data[o]
                });
            }
        } else {
            series.push({data:data});
        }
        this.series = series;

        //whether accumulate when range calculation
        this.accumulation = false;

    };
    Series.prototype = {
        constructor:Series,
        getRange:function (arr) {
            /*
             * get the max and min value of data
             * return Object
             * {
             *     max:
             *     min:
             * }
             * */
            var series = this.series,
                accumulation = this.accumulation,
                max , min;

             if(!arr){
                //it means all data
                arr = [];
                this.series.forEach(function(s,i){
                    arr.push(i);
                });
            }
            arr.forEach(function (index) {
                //get the max and min value depends on the data format
                var d = series[index].data
                if (isArray(d)) {
                    var iMax = Math.max.apply(Math, d),
                        iMin = Math.min.apply(Math, d);
                    (max === undefined || iMax > max) && (max = iMax);
                    (min === undefined || iMin < min) && (min = iMin);
                } else if (isObject(d)) {
                    for (var o in d) {
                        (max === undefined || d[o] > max) && (max = d[o]);
                        (min === undefined || d[o] < min) && (min = d[o]);
                    }
                } else {
                    (max === undefined || d > max) && (max = d);
                    (min === undefined || d < min) && (min = d);
                }
            });
            if (accumulation) {
                //accumulate max
                var ac
                arr.forEach(function (index, j) {
                    var d = series[index].data;
                    if (isArray(d)) {
                        ac = ac || [];
                        d.forEach(function (value, i) {
                            ac[i] === undefined ? ac[i] = value : ac[i] += value;
                        });
                    } else if (isObject(d)) {
                        ac = ac || {};
                        for (var o in d) {
                            ac[o] === undefined ? ac[o] = d[o] : ac[o] += d[o];
                        }
                    } else {
                        ac = ac || [];
                        ac[j] = d;
                    }
                });
                if (isArray(ac)) {
                    max = Math.max.apply(Math, ac);
                } else if (isObject(ac)) {
                    max = undefined;
                    for (var o in ac) {
                        (max === undefined || ac[o] > max) && (max = ac[o]);
                    }
                }
            }

            return {
                max:max,
                min:min
            }
        },
        getSeries:function () {
            return this.series;
        },
        getLabels:function () {
            /*
             * return labels for auto generated x Axis
             * labels depends on the data
             * so sometimes labels will be array of empty string
             * */

            var labels = [],
                _labels = {},
                isObj = false,
                isArr = false,
                len = 0
            this.series.forEach(function (item) {
                if (item.name && Venus.util.isNumber(item.data)) {
                    //if there is 'name',then use the name
                    labels.push(item.name)
                }
                else {
                    var data = item.data;
                    if (isArray(data)) {
                        //if data is array ,that means got no labels
                        isArr = true;
                        len = Math.max(data.length, len)
                    }
                    else if (isObject(data)) {
                        for (var o in data) {
                            //cache the labels in the object _labels first , this will avoid duplicated labels
                            //and later will convert it to array
                            isObj = true;
                            _labels[o] = true;
                        }
                    } else {
                        labels.push('');
                    }
                }
            });
            if (isObj) {
                //convert _labels to array
                labels = [];
                for (var o in _labels) {
                    labels.push(o);
                }
            }
            if (isArr) {
                // data is Array ,create an array of empty string,length = len
                labels = new Array(len);
                // DON'T USE forEach , it won't work here
                for (var i = 0; i < len; i++) {
                    labels[i] = ''
                }
            }
            return labels;
        }
    }

    /*Class Series End */


    /*Class Axis Begin*/

    var Axis = function (options, series, paper) {
        var defaultOptions = {
            percent:0.8,            //length of the axis , percent of svg
            total:0,                //how many ticks to be shown
            max:0,
            min:0,
            tickSize:0,             //tick size in value , optional
            tickWidth:0,            //tick size in pixel , optional
            ticks:[],               //ticks
            rotate:0,               //rotate 0-360 in counter-clockwise
            pop:0,                  // empty ticks before
            _svgWidth:0,
            _svgHeight:0,
            labelRotate:0,          //rotate 0-360 of the labels in clockwise
            enable:true,            //visible or not
            fontSize:12             //label font size
        };

        this.options = mix(defaultOptions, options || {});

        this.stage = paper;

        this.events = new Venus.util.CustomEvent();

        this.model = {};
        this.view = {};
        this.events = new util.CustomEvent();

        this.autoModel();

    }

    Axis.prototype = {
        constructor:Axis,
        autoModel:function () {
            /*
             * auto compute visible ticks ,according to width ,origin ticks , data and so on
             * model got key attribute below
             * {
             *     max,
             *     min,
             *     total,
             *     ticks,
             *     tickSize,
             *     tickWidth,
             *     totalWidth,
             *     pop,
             *     rotate,
             * }
             * */
            var opt = this.options,
                model = this.model,
                alpha = Math.atan(opt._svgHeight / opt._svgWidth),
                beta = (opt.rotate || 0) * PI / 180,
                percent = opt.percent,
                maxWidth = beta <= alpha ? opt._svgWidth / Math.cos(beta) : opt._svgHeight / Math.sin(beta),
                total, i,l;

            model.pop = opt.pop || 0;
            model.rotate = opt.rotate;
            model.ticks = [];

            if (opt.ticks && opt.ticks.length) {
                //got ticks and generate the visible ticks
                if (opt.tickSize) {
                    model.tickSize = opt.tickSize;
                } else {
                    //compute the tickSize
                    if (opt.total) {
                        total = Math.min( opt.total, opt.ticks.length);
                    } else {
                        total = opt.ticks.length;
                        while (total) {
                            if (opt.fontSize * (total + model.pop) > maxWidth * percent) {
                                total = Math.floor(total / 2);
                            } else {
                                break;
                            }
                        }
                    }
                    if(total==1){
                        total = 2;
                        model.pop = 1;
                    }
                    model.tickSize = Math.ceil((opt.ticks.length - 1) / (total - 1)) || 1;

                }
                total = Math.ceil((opt.ticks.length - 1) / model.tickSize) + 1;
                for ( i = 0, l = opt.ticks.length - 1; i < l; i += model.tickSize) {
                    model.ticks.push(i);
                }
                if (i == l) {
                    model.ticks.push(i);
                }
                model.tickWidth = parseInt( opt.tickWidth || maxWidth * percent / (total + model.pop -1));
                model.totalWidth = model.tickWidth * (total + model.pop-1);
                model.total = total;
            } else {
                //got min and max
                var range = this.autoRange(opt.min, opt.max, opt.total);
                model.max = range.max;
                model.min = range.min;
//                if(opt.total){
//                    model.tickSize = Math.ceil((model.max - model.min)/(opt.total-1));
//                }else{
//                    model.tickSize = opt.tickSize || range.step;
//                }
                model.tickSize = range.step;

//                model.total = Math.ceil((model.max-model.min)/model.tickSize)+1;
                model.total = range.total;

                model.tickWidth = opt.tickWidth || maxWidth * percent / (model.total + model.pop-1);
                model.totalWidth = model.tickWidth * (model.total + model.pop-1);
                for ( i = model.min, l = model.max; i < l; i+=model.tickSize) {
                    model.ticks.push(i);
                }
                model.ticks.push(i);
            }



         },
        set:function(key,value){
            /*
            * set model options
            * */
            var change = false;
            if (isObject(key)) {
                for (var o in key) {
                    if(!key.hasOwnProperty(o)){
                        continue;
                    }
                    if (this.options[o] != key[o]) {
                        this.options[o] = key[o];
                        change = true;
                    }
                }
            } else {
                if (this.options[key] !== value) {
                    this.options[key] = value;
                    change = true;
                }
            }

            if(change){
                this.autoModel();
            }

            if (change && this.axisRendered) {
                this.render();
                this.events.fire('model_change',this.model);
            }

         },
        autoRange:function (min, max, totalTick) {
            /*
             * generate axis ticks according to min and max
             *
             * */
            min === undefined && (min = 0);
            max === undefined && (max = 10);
            var iDelta = max - min,
                iExp,
                iMultiplier,
                dSolution ,
                dMultiCal,
                dInterval,
                start, end, mul = 1;

            totalTick = totalTick || 5;

//            if (iDelta < 1) { //Modify this by your requirement.
//                max += ( 1 - iDelta) / 2;
//                min -= ( 1 - iDelta) / 2;
//            }
            iDelta = max - min;

            iExp = parseInt(Math.log(iDelta) / Math.log(10)) - 2;
            iMultiplier = Math.pow(10, iExp);
            dSolution = [1, 2, 2.5, 5, 10, 20, 25, 50, 100, 200, 250, 500, 1000,5000];
            for (var i = 0, l = dSolution.length; i < l; i++) {
                dMultiCal = iMultiplier * dSolution[i];
                if ((parseInt(iDelta / dMultiCal) + 1) <= totalTick) {
                    break;
                }
            }
            dInterval = iMultiplier * dSolution[i];
            //fix float bug
            if(dInterval<1){
                mul = dInterval.toString().split('.')[1].length;
                mul = Math.pow(10, mul || 0);
            }

           // start = (Math.ceil(min / dInterval) - 1) * dInterval;
            start = Math.abs(min) == dInterval ? ( min - dInterval) : Math.floor(min / dInterval) * (dInterval*mul)/mul;
            for (i = 0; 1; i++) {
                if (start + dInterval * i > max)
                    break;
                end = (start*mul + dInterval * (i + 1)*mul) / mul;
            }


            return {
                max:end,
                min:start,
                step:dInterval,
                total: parseInt((end-start)/dInterval +1)
            }
        },
        render:function(){
            var view  = this.view,
                model = this.model,
                stage = this.stage,
                opt = this.options,
                pathString = "",
                beginX = model.beginX,
                beginY = model.beginY,
                i, l,count=0,
                tickHeight = 2,
                labelMarginTop = 10,
                hasTicks = opt.ticks && opt.ticks.length,
                label,
                bbox,
                mul = 1,
                skip;//if label text is too wide , skip some

            if (!view.axisElement) {
                view.axisElement = stage.path();
            }
            if (view.labelElements) {
                view.labelElements.forEach(function (label) {
                    label.remove();
                });
                view.labelElements.clear();
            } else {
                view.labelElements = stage.set();
            }

            pathString += ("M" + beginX + " " + beginY);
            for (i = 0, l = model.pop; i < l; i++) {
                pathString += ("h" + model.tickWidth + "v" + tickHeight + "v" + -tickHeight);
            }
            if(hasTicks){
                i = 0;
                l = opt.ticks.length-1;
            }else{
                i = model.min;
                l = model.max;
            }
            if(model.tickSize<1){
                mul = model.tickSize.toString().split('.')[1].length;
                mul = Math.pow(10, mul || 0);
            }
            while (i < l) {
                if (count != 0) {
                    pathString += (  "h" + model.tickWidth + "v" + tickHeight + "v" + -tickHeight );
                }
                if (!skip || skip <= 1 || count % skip == 0) {
                    label = stage.text((beginX + (count + model.pop) * model.tickWidth), beginY + labelMarginTop * (model.rotate > 0 ? -1 : 1), hasTicks? opt.ticks[i] :i).rotate(360 - model.rotate, beginX, beginY).attr({
                        'font-size':this.options.fontSize
                    });
                    view.labelElements.push(label);
                    bbox = label.getBBox();
                    if (this.options.labelRotate) {
                        label.rotate(this.options.labelRotate).translate(bbox.width / 2, 0)
                    }
                    skip = Math.ceil((bbox.width * Math.cos((this.options.labelRotate || 0) * PI / 180)+20) / model.tickWidth);
                }
                i  = (i *mul+ (model.tickSize*mul))/mul;
                count++;
            }

            pathString += ( "h" + model.tickWidth + "v" + tickHeight + "m" + -tickHeight );
            if ((opt.ticks && opt.ticks.length && i == l) || model.max) {
                if (!skip || skip <= 1 || count % skip == 0) {
                    label = stage.text((beginX + (count + model.pop) * model.tickWidth), beginY + labelMarginTop * (model.rotate > 0 ? -1 : 1), hasTicks ? opt.ticks[i] : i).rotate(360 - model.rotate, beginX, beginY).attr({
                        'font-size':this.options.fontSize
                    });
                    view.labelElements.push(label);
                    if (this.options.labelRotate) {
                        bbox = label.getBBox();
                        label.rotate(this.options.labelRotate).translate(bbox.width / 2, 0)
                    }
                }
            }

            view.axisElement.attr({
                path:pathString,
                opacity:.9
            });
            if(model.rotate){
               // view.axisElement.rotate((360-model.rotate),model.beginX,model.beginY)
                view.axisElement.transform('R'+(360-model.rotate)+","+model.beginX+','+model.beginY)
            }

            if (!this.options.enable) {
                //if invisible ,hide the elements
                //but the coordinate is actually exist
                view.axisElement.hide();
                view.labelElements.hide();
            }
        },
        on:function(fn){
            this.events.on('model_change',fn);
        }
    };

    /*Class Axis End*/


    /*Class Legend Begin*/

    var Legend = function (chart, options, paper) {
        /*
         * Class Legend
         * @param series{Series} instance of Series
         * @param options{Object}
         * @param paper{Raphael} instance of Raphael
         *
         * */
         var defaultOption = {
                position:['right', 'top'],  //position of the legend contains two elements (horizontal and vertical) each could be string and number
                format:'{name}',            //format of the texts
                fontSize:12,                //text font size
                colors:[],                  //colors ,parsed as the dpchart.colors
                direction:'vertical'       //how to layout the items
            }, i, l
            , series = chart.series
            , data = series.getSeries()
            , width = 15                        //item width
            , lineHeight = 20                   // item line height
            , span = 10                         //distance between item and text
            , border                            // rect element of border
            , startX = 0
            , startY = 0
            , item
            , icon
            , text
            , textWidth
            , totalWidth
            , totalHeight
            , itemSet                           // set of items
            , textSet                           // set of texts
            , margin = 10                       // margin to svg boundary
            , padding = 10
            , names
            , colors
            , isVertical,
            left , top,
            active, activeEvent, activeArray,
            self = this,
            opt = this.options = mix(defaultOption, options);

        //Raphael Set to contain the elements
        itemSet = paper.set();
        textSet = paper.set();

        colors = opt.colors;

        names = options.names;

        //vertical or horizontal
        isVertical = opt.direction == 'vertical';

        //used to compute the total width
        isVertical ? totalWidth = [] : totalWidth = 0;

        for (i = 0, l = data.length; i < l; i++) {
            //create the raphael elements
            var _x , _y;
            if (isVertical) {
                _x = startX + padding;
                _y = startY + padding + i * lineHeight;

            } else {
                _x = startX + padding;
                _y = startY + padding;
            }
            icon = chart.iconFactory.create(i, _x+width/2, _y+width/2, width)
            item = icon.icon;
            item._iconObj = icon;

            text = isVertical ? paper.text(startX + width + span + padding, startY + padding + i * lineHeight + width / 2, names[i]) : paper.text(startX + width + span + padding, startY + padding + lineHeight / 2, names[i]).attr({
                'font-size':opt.fontSize
            });

            textWidth = text.getBBox().width;
            text.translate(textWidth / 2, 0);
            isVertical || (startX += (width + padding + span + textWidth));

            item.attr({
                'fill':colors[i],
                'stroke-width':0,
                'cursor':'pointer'
            });
            itemSet.push(item);
            textSet.push(text);
            isVertical ? totalWidth.push(textWidth) : totalWidth += textWidth;
        }
        totalWidth = isVertical ? Math.max.apply(Math, totalWidth) + width + span + padding * 2 : (width + span) * l + (l + 1) * padding + totalWidth;
        totalHeight = isVertical ? lineHeight * l + padding * 2 : padding * 2 + lineHeight;

        //border
        var _lastX,_lastY;
        border = paper.rect(0, 0, totalWidth, totalHeight, 5).attr({
            'stroke-width':1,
            'stroke':'gray',
            'fill':"#FFF",
            'cursor':'move'
        }).drag(function(dx,dy){
                var shiftX = dx - _lastX,
                    shiftY = dy - _lastY;
                self.setPosition(shiftX,shiftY);
                _lastX = dx;
                _lastY = dy;
            },function(){
                _lastX = 0;
                _lastY = 0;
            });

        itemSet.toFront();
        textSet.toFront();

        this.border = border;
        this.itemSet = itemSet;
        this.textSet = textSet;

        //convert position string to value
        if (typeof (left = this.options.position[0]) == "string") {
            if (left == "right") {
                left = this.options._svgWidth - totalWidth - margin;
            } else if (left == "center") {
                left = this.options._svgWidth / 2 - totalWidth / 2
            } else {
                left = margin
            }
        }

        if (typeof (top = this.options.position[1]) == "string") {
            if (top == "bottom") {
                top = this.options._svgHeight - totalHeight - margin
            } else if (top == 'center') {
                top = this.options._svgHeight / 2 - totalHeight / 2
            } else {
                top = margin
            }
        }

        this.setPosition(left, top);

        //init active , all is active
        active =  this.active = [];
        itemSet.forEach(function(){
            active.push(true);
        });
        activeArray = this.activeArray = active.slice(0);
        activeEvent =  this.activeEvent = new util.CustomEvent();


        //bind default click event
        this.on('click', function (e, i) {
            active[i] ? active[i] = false : active[i] = true;
            active[i] ? this.attr('fill', colors[i]) : this.attr('fill', 'gray');
            activeArray = self.activeArray = [];
            active.forEach(function(truth,index){
                truth && activeArray.push(index);
            });
            activeEvent.fire('change', active,activeArray);
        });
    };
    Legend.prototype = {
        constructor:Legend,
        setPosition:function (left, top) {
            //set the position of the legend
            //relative ,not absolute
            this.itemSet.translate(left, top);
            this.textSet.translate(left, top);
            this.border.translate(left, top);
        },
        on:function (name, fn) {
            //bind DOM Events on legend item
            var event;
            if ((event = this.itemSet[name] ) && util.isFunction(event)) {
                //has function such as click, mouseover
                this.itemSet.forEach(function (item, i) {
                    item[name](function (e) {
                        fn.call(item, e, i);
                    });
                })
            }
            return this;
        },
        onActiveChange:function (fn) {
            this.activeEvent.on('change', fn);
        }
    }

    /*Class Legend End*/


    /*Class Grid Begin*/

    var Grid = function (options, paper) {
        var defaultOption = {
                'color':'#ccc', //color of the grid
                'rows':[], //coordinate
                'columns':[],
                'width':0, //length of the row
                'height':0, //length of the column
                'stroke-width':1,
                'opacity':0.2,
                _x:0, //x coordinate of y axis
                _y:0                    //y coordinate of x axis ,these are used as the start position
            };
        this.options = mix(defaultOption, options);
        this.paper = paper;
        this.rows = paper.set();
        this.columns = paper.set();
        this.render();
    }
    Grid.prototype = {
        constructor:Grid,
        render:function(){
            this.rows.forEach(function(r){
                r.remove();
            }).clear();
            this.columns.forEach(function(c){
                c.remove();
            }).clear();

            var options = this.options,
                paper = this.paper,
                lineAttr = {
                stroke:options.color,
                "stroke-width":options['stroke-width'],
                'opacity':options.opacity
                },self = this;

            if (options.rows && options.rows.length) {
                //draw rows
                options.rows.forEach(function (value) {
                    self.rows.push(paper.path('M' + options._x + "," + value + "h" + options.width).attr(lineAttr));
                });
                self.rows.toBack();
            }
            if (options.columns &&options.columns.length) {
                //draw columns
                options.columns.forEach(function (value) {
                    self.columns.push(paper.path('M' + value + "," + options._y + "v" + -options.height).attr(lineAttr));
                });
                self.columns.toBack();
            }
        }
    }


    /*Class Grid End*/



    /*
        extends Raphael Element , toolTip function
    */
    var toolTip = function (paper, x, y, texts, side) {
            //extend the Raphael Element and provide the toolTip Function
            //@param x , y position of the tip
            //@texts{Array or String} each line of text
            //@side{String} 'left','top','right' or 'bottom'
            var tip, labels,
                side = side || 'top',
                path = function (width, height, padding) {
                    var p = ['M', x, y],
                        arrowWidth = 5,
                        left, top;

                    height += (2 * padding || 0);
                    width += (2 * padding || 0);
                    switch (side) {
                        case 'right':
                            //arrow at the left side and content at right
                            height = Math.max(arrowWidth * 2, height);
                            p.push('l', arrowWidth, -arrowWidth);
                            p.push('v', -(height / 2 - arrowWidth));
                            p.push('h', width);
                            p.push('v', height, 'h', -width);
                            p.push('v', -(height / 2 - arrowWidth));
                            p.push('l', -arrowWidth, -arrowWidth);
                            left = x + arrowWidth;
                            top = y - height / 2;
                            break;
                        case 'top':
                            width = Math.max(arrowWidth * 2, width);
                            p.push('l', -arrowWidth, -arrowWidth);
                            p.push('h', -(width / 2 - arrowWidth));
                            p.push('v', -height, 'h', width, 'v', height);
                            p.push('h', -(width / 2 - arrowWidth));
                            p.push('l', -arrowWidth, arrowWidth);
                            left = x - width / 2;
                            top = y - arrowWidth - height;
                            break;
                        case 'left':
                            height = Math.max(arrowWidth * 2, height);
                            p.push('l', -arrowWidth, arrowWidth);
                            p.push('v', height / 2 - arrowWidth);
                            p.push('h', -width, 'v', -height, 'h', width);
                            p.push('v', height / 2 - arrowWidth);
                            p.push('l', arrowWidth, arrowWidth);
                            left = x - arrowWidth - width;
                            top = y - height / 2;
                            break;
                        case 'bottom':
                            width = Math.max(arrowWidth * 2, width);
                            p.push('l', arrowWidth, arrowWidth);
                            p.push('h', width / 2 - arrowWidth);
                            p.push('v', height, 'h', -width, 'v', -height);
                            p.push('h', width / 2 - arrowWidth);
                            p.push('l', arrowWidth, -arrowWidth);
                            left = x - width / 2;
                            top = y + arrowWidth;
                            break;

                    }
                    p.push('z');
                    return {
                        path:p,
                        box:{
                            left:left,
                            top:top,
                            width:width,
                            height:height
                        }
                    };
                }

            !isArray(texts) && (texts = [texts]);
            labels = paper.set();
            var width = [], height = 0,
                bBox,
                text,
                paddingToBorder = 8,
                p;


            texts.forEach(function (t, i) {
                text = paper.text(x, -100, t);
                labels.push(text);
                bBox = text.getBBox();
                //seems Raphael's bug , when contains（ ）
                t.toString().indexOf('（')!=-1 && (bBox.width += 10);
                t.toString().indexOf('）')!=-1 && (bBox.width += 10);

                text.attr({
                    'opacity':0,
                    'font-size':12
                });
                width.push(bBox.width);
            });
            if (this._venus_tooltip_show)
                return;
            p = path(Math.max.apply(Math, width)+10, texts.length * bBox.height, paddingToBorder);
            tip = paper.path();
            labels.toFront();
            tip.attr({
                path:p.path,
                fill:"#FFF",
                "stroke-width":2,
                "fill-opacity":.1,
                'stroke-linejoin':'round',
                'stroke':'#4572A7',
                'opacity':'0'
            }).animate({'opacity':1, 'fill-opacity':.85}, 100);
            labels.animate({'opacity':1}, 100);
            labels.forEach(function (la, i) {
                la.attr({
                    'y':p.box.top + (i + .5) * bBox.height + paddingToBorder,
                    'x':p.box.left + p.box.width / 2
                })
            })
            this._venus_tooltip_labels = labels;
            this._venus_tooltip = tip;
            this._venus_tooltip_show = true;
            return toolTip;
        },
        toolTipHide = function () {
            var self = this,
                cb = function () {
                this.remove();
                self._venus_tooltip_show = false;
            }, animate = Raphael.animation({'opacity':0}, 100, 'linear', cb);
            this._venus_tooltip && (this._venus_tooltip.animate(animate) ) && (this._venus_tooltip_labels.animate(animate) ) ;
        };
    Raphael.el.toolTip = toolTip;
    Raphael.el.toolTipHide = toolTipHide;


    //for unit test , temporary bind Classes on Chart
    Chart.Series = Series;
    Chart.Axis = Axis;
    Chart.Legend = Legend;
    Chart.Grid = Grid;

    Venus.SvgChart = Chart;

})(this);


/*
* @change log :
*
*   2012-09-25: version 1.1
*   1. options change:
*       1.1 add 'tooltip' function to config the tooltip
*           {x:String,y:String,label:String} will be parsed to this function
*       1.2 add 'axisUsage' to config which two axises to use
*       1.3 add 'icons' to config which icon to used for each series
*           call this.iconFactory.create to create icons
*       1.4 axis config optimized :
*           tickWidth,tickSize,max,min
*           are now optional
*       1.5 options object now cloned and mix to default options , outer options object stays no change
*
*   2. Class Axis rebuild:
*       2.1 Axis now is separated as model and view
*           model can be changed out of the Axis instance
*           view binds to the model and will auto render when model changes
*           charts now rely on the model , bind to model and auto change when model changes
*           model got some key attributes , see Axis.model
*      2.2 range and ticks are auto computed and also can config in options
*      2.3 remove prototype function getX,getY,getOrigin,setPosition,getAngel,getTicksPos
*      2.4 coordinate service now is provided by Chart.coordinate
*
*   3. Class Series change:
*       3.1 Series.getRange() can receive an array which is indexes of series to get the appointed range of data
*
*   4. Class Legend change:
*       4.1 legend now use iconFactory to create icons
*       4.2 legend now is dragable
*
*   4. Class Grid change:
*       4.1 Grid now are bind to the axis model and rerender when model changes
*
*   5. Chart.coordinate added:
*       4.1 coordinate object manages the axises and provide some services to help draw charts
*       4.2 use coordinate.get(x,y) to replace axis.getX, axis.getY
*
*   6. add _initLabels() in the main drawing flow to provide the labels use by legend , tooltip , axis
*
*   7. add _initIconFactory() in the main drawing flow to init the iconFactory object
*
*   8. charts are bind to the axis model and do some changes when the model change
*
*   9. Line Chart
*      9.1 Line Dot now stays the same as legend both calls iconFactory to create icons
*      9.2 Tip will show when close to dot and add 'hoverRadius' to config the response radius,default to 50
*      9.3 set 'columnHover' default to false since the 'hoverRadius' is on
*      9.4 use mouse event clientX,and clientY to implement columnHover instead of invisible column bars
*
*   10.Bar Chart
*      10.1 bind to axis model
*
*   11.tooltip
*      11.1 tooltip ui rebuild and fix some bugs
*
* */